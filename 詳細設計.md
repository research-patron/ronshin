# 論文ベース新聞一面生成システム 詳細設計書（改訂版）

## 1. システム概要
本システムは学術論文をAIで解析し、新聞一面形式に自動変換するWebアプリケーションです。研究者間の情報共有や一般の方々への研究成果の可視化を目的としています。

### 1.1 システムアーキテクチャ
- **クライアント-サーバー型アーキテクチャ**
  - フロントエンド: React/TypeScript (SPA)
  - バックエンド: Google Cloud Functions (Python)
  - データベース: Firebase (Firestore)
  - ストレージ: Cloud Storage
  - AI処理: Vertex AI Gemini 2.0 Flash
  - PDF処理: React-PDF, PDFKit
  - 決済処理: Stripe API
  - CI/CD: Google Cloud Build

### 1.2 プロジェクト構造
```
/
├── client/                   # フロントエンド（React/TypeScript）
│   ├── src/
│   │   ├── components/      # Reactコンポーネント
│   │   │   ├── auth/       # 認証関連
│   │   │   ├── papers/     # 論文関連
│   │   │   └── newspapers/ # 新聞関連
│   │   ├── routes/         # ルーティング設定
│   │   ├── hooks/          # カスタムフック
│   │   ├── services/       # APIサービス
│   │   ├── utils/          # ユーティリティ
│   │   └── App.tsx         # アプリケーションルート
│   ├── public/             # 静的ファイル
│   ├── webpack.config.js   # Webpack設定
│   └── package.json
│
└── server/                  # バックエンド（Google Cloud Functions）
    ├── src/
    │   ├── api/            # APIエンドポイント
    │   │   ├── auth/       # 認証関連
    │   │   ├── papers/     # 論文関連
    │   │   └── newspapers/ # 新聞関連
    │   ├── ai/             # AI処理関連
    │   │   ├── services/   # AIサービス実装
    │   │   ├── prompts/    # プロンプトテンプレート
    │   │   └── utils/      # AI関連ユーティリティ
    │   └── utils/          # 共通ユーティリティ
    ├── requirements.txt    # Python依存関係
    └── main.py            # エントリーポイント
```

### 1.2 全体構成図
```
┌─────────────┐     ┌───────────────┐     ┌─────────────────┐
│             │     │               │     │                 │
│ クライアント  │◄────►│ Firebase     │◄────►│ Vertex AI       │
│ (React SPA) │     │ (BaaS)       │     │ Gemini 2.0 Flash  │
│             │     │               │     │                 │
└─────────────┘     └───────────────┘     └─────────────────┘
                          ▲
                          │
                          ▼
                    ┌──────────────┐
                    │              │
                    │ Stripe API   │
                    │ (決済処理)    │
                    │              │
                    └──────────────┘
```

## 2. 技術スタック詳細

### 2.1 フロントエンド
- **フレームワーク/言語**:
  - React 18.x
  - TypeScript 5.x
- **状態管理**: Redux Toolkit
- **ルーティング**: React Router v6
- **UI/スタイリング**:
  - Material UI v5.x
  - Styled Components
  - Material Icons
- **フォーム管理**: React Hook Form + Zod
- **PDF生成/操作**: React-PDF, PDFKit
- **グラフ/可視化**: D3.js
- **HTTP通信**: Axios
- **テスト**:
  - Jest
  - React Testing Library
  - Cypress
- **ビルドツール**: 
  - Webpack 5
  - Babel
- **コンポーネント設計**: Atomic Design
- **開発ツール**:
  - ESLint
  - Prettier
  - Husky (Git hooks)

### 2.2 バックエンド
- **言語/ランタイム**: Python 3.11
- **サーバーレス**:
  - Google Cloud Functions
  - Cloud Build (CI/CD)
- **データベース**: Firebase Firestore
- **ストレージ**: Cloud Storage
- **認証**: Firebase Authentication
- **API設計**:
  - RESTful API
  - OpenAPI (Swagger) 仕様
- **ユーティリティ**:
  - google-cloud-functions
  - firebase-admin
  - pydantic (バリデーション)
  - pytest (テスト)
- **バッチ処理**: Cloud Scheduler
- **キャッシュ戦略**: Cloud CDN

### 2.3 AI/ML
- **論文解析**: Vertex AI Gemini 2.0 Flash
  - テキスト解析・要約
  - 関連性分析
  - 見出し・記事生成
  - **プロンプト設計**:
    - 体系的なプロンプトテンプレート
    - 論文構造認識プロンプト
    - 新聞スタイル変換プロンプト
  - **コンテキスト管理**:
    - トークン最適化
    - 重要情報抽出戦略
- **画像処理**:
  - OCR処理 (論文PDFからのテキスト抽出)
  - 論文からの図表抽出処理
  - テーブル変換・正規化処理

### 2.4 インフラ
- **クラウド**: Google Cloud Platform
  - **計算リソース**: 標準Compute Engineインスタンス (e2-standard-4)
  - **スケーリング**: 自動スケーリングルール設定
  - **リージョン設定**: asia-northeast1 (東京)
- **CI/CD**: GitHub Actions
  - **テスト・デプロイパイプライン**
  - **環境分離**: 開発/ステージング/本番
- **監視/ロギング**: Firebase Analytics, Google Cloud Monitoring
  - **アラート設定**: エラー率、レスポンスタイム閾値
  - **ログ集約**: Cloud Logging
- **バックアップ**: 自動日次バックアップ (GCS)
  - **リテンション期間**: 30日間
  - **復旧テスト**: 月次実施

## 3. データベース設計

### 3.1 Firestoreコレクション設計

#### users
```
{
  uid: string (PK),  // Firebase Authenticationから生成されるID
  email: string,
  displayName: string,
  profileImageUrl: string,
  membershipTier: string,  // "free" | "premium"
  membershipStartDate: timestamp,
  membershipEndDate: timestamp,
  paymentId: string,  // Stripe顧客ID
  generatedCount: number,  // 生成回数カウント（無料会員用）
  savedNewspapersCount: number,  // 保存した新聞数（無料会員用）
  createdAt: timestamp,
  updatedAt: timestamp,
  lastLoginAt: timestamp,
  preferredLanguage: string,  // "ja" | "en" | "zh" (多言語対応用)
  settings: {
    notifications: boolean,
    theme: string  // "light" | "dark" | "system"
  }
}
```

#### newspapers
```
{
  id: string (PK),
  creatorId: string (FK -> users.uid),
  title: string,
  templateId: string,
  isPublic: boolean,
  shareSettings: {
    type: string,  // "private" | "group" | "public"
    groupIds: string[],  // 共有するグループIDリスト
    viewCount: number,  // 閲覧数カウント
    shareUrl: string  // 共有用一意URL
  },
  content: {
    header: {
      newspaperName: string,
      date: string,
      issueNumber: string
    },
    mainArticle: {
      headline: string,
      subheadline: string,
      content: string,
      imageUrl: string,
      paperIds: string[]  // 関連論文ID
    },
    subArticles: [
      {
        headline: string,
        content: string,
        imageUrl: string,
        paperId: string
      }
    ],
    sidebarContent: string,
    columnContent: string,
    adContent: string,  // 無料会員用広告
    footer: string
  },
  customSettings: {
    fontFamily: string,
    colorScheme: string,
    logoUrl: string
  },
  exportHistory: [
    {
      type: string,  // "pdf" | "png" | "print"
      url: string,  // 生成ファイルへのパス
      createdAt: timestamp
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### papers
```
{
  id: string (PK),
  uploaderId: string (FK -> users.uid),
  title: string,
  authors: string[],
  journal: string,
  publicationDate: string,
  doi: string,
  fileUrl: string,  // Storage内のPDFパス
  fileSize: number,
  metadata: {
    abstract: string,
    keywords: string[],
    figures: [
      {
        id: string,
        caption: string,
        imageUrl: string,
        page: number,
        importance: number  // AIによる重要度スコア (0-100)
      }
    ],
    tables: [
      {
        id: string,
        caption: string,
        data: string,  // JSON形式テーブルデータ
        page: number
      }
    ],
    citations: [
      {
        id: string,
        text: string,
        reference: string
      }
    ],
    extractedText: string,  // 抽出されたフルテキスト
  },
  aiAnalysis: {
    summary: string,
    keypoints: string[],
    significance: string,
    relatedTopics: string[],
    academicField: string,
    technicalLevel: string,  // "beginner" | "intermediate" | "advanced"
    aiConfidenceScore: number  // 解析精度の自己評価スコア (0-100)
  },
  processingStatus: string,  // "pending" | "processing" | "completed" | "failed"
  errorLogs: [
    {
      timestamp: timestamp,
      code: string,
      message: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### groups
```
{
  id: string (PK),
  name: string,
  description: string,
  creatorId: string (FK -> users.uid),
  members: [
    {
      userId: string,
      role: string,  // "admin" | "member" | "viewer"
      joinedAt: timestamp,
      lastActivity: timestamp
    }
  ],
  sharedNewspapers: string[],  // 新聞IDリスト
  invitationLinks: [
    {
      id: string,
      url: string,
      expiresAt: timestamp,
      usedCount: number,
      maxUses: number  // 招待制限数
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### templates
```
{
  id: string (PK),
  name: string,
  description: string,
  previewImageUrl: string,
  isPremium: boolean,
  category: string,  // "standard" | "academic" | "magazine" | "tabloid"
  layout: {
    // レイアウト定義（JSON形式）
    // 要素の位置、サイズ、スタイルなど
    version: string,
    components: [
      {
        type: string,
        id: string,
        position: { x: number, y: number },
        size: { width: number, height: number },
        styles: object,
        content: object
      }
    ]
  },
  compatibleLanguages: string[],  // 対応言語リスト
  usageCount: number,  // 使用回数（人気度）
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### payments
```
{
  id: string (PK),
  userId: string (FK -> users.uid),
  stripeCustomerId: string,
  stripeSubscriptionId: string,
  plan: string,  // "monthly" | "yearly"
  amount: number,
  currency: string,
  status: string,  // "active" | "canceled" | "past_due"
  startDate: timestamp,
  endDate: timestamp,
  paymentMethod: {
    type: string,  // "credit_card" | "bank_transfer"
    last4: string,
    brand: string,
    expiryDate: string
  },
  invoices: [
    {
      id: string,
      amount: number,
      status: string,
      paidAt: timestamp,
      receiptUrl: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### systemSettings
```
{
  id: string (PK),
  aiSettings: {
    modelVersion: string,
    maxTokens: number,
    temperatureDefault: number,
    contextWindowSize: number
  },
  freeUserLimits: {
    generationCount: number,  // 月当たりの生成可能回数
    savedNewspaperCount: number,  // 保存可能な新聞数
    exportFormats: string[]  // 利用可能なエクスポート形式
  },
  premiumUserLimits: {
    maxStorageSize: number,  // GB単位
    maxFileSize: number  // MB単位
  },
  maintenanceMode: boolean,
  notificationMessages: [
    {
      id: string,
      message: string,
      severity: string,  // "info" | "warning" | "error"
      startDate: timestamp,
      endDate: timestamp
    }
  ],
  updatedAt: timestamp,
  updatedBy: string
}
```

### 3.2 Firebase Storage構造
```
/papers/{userId}/{paperId}.pdf  // アップロードされた論文PDF
/figures/{paperId}/{figureId}.{ext}  // 論文から抽出された図表
/tables/{paperId}/{tableId}.json  // 論文から抽出されたテーブルデータ
/newspapers/{newspaperId}/preview.png  // 新聞プレビュー画像
/newspapers/{newspaperId}/export.pdf  // エクスポートされたPDF
/newspapers/{newspaperId}/export.png  // エクスポートされたPNG
/logos/{userId}/custom_logo.{ext}  // カスタムロゴ（有料会員）
/templates/{templateId}/preview.png  // テンプレートプレビュー
/system/backups/daily/{date}/  // システムバックアップ
```

### 3.3 データベースインデックス設計
効率的なクエリ処理のために以下のインデックスを設定:

```
// 新聞検索用複合インデックス
- コレクション: newspapers
  フィールド: 
    - creatorId (ASC)
    - createdAt (DESC)

// 共有新聞検索
- コレクション: newspapers
  フィールド:
    - shareSettings.type (ASC)
    - createdAt (DESC)

// 論文検索
- コレクション: papers
  フィールド:
    - uploaderId (ASC)
    - createdAt (DESC)

// グループメンバーシップ
- コレクション: groups
  フィールド:
    - "members.userId" (ASC)
    - createdAt (DESC)
```

## 4. API設計

### 4.1 Firebase Functions API実装詳細

#### 認証関連
- **createUser**: 新規ユーザー登録
  ```python
  from firebase_admin import auth, firestore
  from google.cloud.functions_framework import http
  from datetime import datetime
  import functions_framework
  from typing import Dict, Any
  
  @functions_framework.http
  def create_user(request) -> Dict[str, Any]:
      """新規ユーザーを作成する関数"""
      try:
          # リクエストデータの取得
          request_json = request.get_json()
          email = request_json.get('email')
          password = request_json.get('password')
          display_name = request_json.get('displayName')
          
          # バリデーション
          if not all([email, password, display_name]):
              return {
                  'error': 'invalid-argument',
                  'message': '必須項目が不足しています'
              }, 400
          
          # Firebaseユーザー作成
          user = auth.create_user(
              email=email,
              password=password,
              display_name=display_name
          )
          
          # Firestoreにユーザーデータ保存
          db = firestore.client()
          now = datetime.utcnow()
          
          db.collection('users').document(user.uid).set({
              'uid': user.uid,
              'email': email,
              'displayName': display_name,
              'membershipTier': 'free',
              'generatedCount': 0,
              'savedNewspapersCount': 0,
              'createdAt': now,
              'updatedAt': now
          })
          
          return {
              'success': True,
              'uid': user.uid
          }
          
      except Exception as e:
          print(f'ユーザー作成エラー: {str(e)}')
          return {
              'error': 'internal',
              'message': 'ユーザー登録に失敗しました'
          }, 500
  ```

- **updateUserProfile**: ユーザープロファイル更新
- **upgradeToPremi um**: 有料会員へのアップグレード処理
  ```python
  import stripe
  from firebase_admin import auth, firestore
  from google.cloud.functions_framework import http
  from datetime import datetime, timedelta
  import functions_framework
  from typing import Dict, Any
  
  stripe.api_key = 'your-stripe-secret-key'
  PRICE_ID_MONTHLY = 'price_monthly_id'
  PRICE_ID_YEARLY = 'price_yearly_id'
  
  @functions_framework.http
  def upgrade_to_premium(request) -> Dict[str, Any]:
      """ユーザーを有料会員にアップグレードする関数"""
      try:
          # 認証確認
          auth_header = request.headers.get('Authorization', '')
          if not auth_header.startswith('Bearer '):
              return {
                  'error': 'unauthenticated',
                  'message': '認証が必要です'
              }, 401
          
          token = auth_header.split('Bearer ')[1]
          decoded_token = auth.verify_id_token(token)
          uid = decoded_token['uid']
          
          # リクエストデータの取得
          request_json = request.get_json()
          payment_method_id = request_json.get('paymentMethodId')
          plan_type = request_json.get('planType')
          
          # Firestoreクライアント
          db = firestore.client()
          
          # ユーザーデータ取得
          user_doc = db.collection('users').document(uid).get()
          if not user_doc.exists:
              return {
                  'error': 'not-found',
                  'message': 'ユーザーが見つかりません'
              }, 404
          
          user_data = user_doc.to_dict()
          
          # Stripe顧客作成/取得
          stripe_customer_id = user_data.get('paymentId')
          if not stripe_customer_id:
              customer = stripe.Customer.create(
                  email=user_data.get('email'),
                  name=user_data.get('displayName'),
                  payment_method=payment_method_id,
                  invoice_settings={
                      'default_payment_method': payment_method_id
                  }
              )
              stripe_customer_id = customer.id
          
          # サブスクリプション作成
          price_id = PRICE_ID_MONTHLY if plan_type == 'monthly' else PRICE_ID_YEARLY
          subscription = stripe.Subscription.create(
              customer=stripe_customer_id,
              items=[{'price': price_id}],
              expand=['latest_invoice.payment_intent']
          )
          
          # ユーザーデータ更新
          now = datetime.utcnow()
          if plan_type == 'monthly':
              end_date = now + timedelta(days=30)
          else:
              end_date = now + timedelta(days=365)
          
          db.collection('users').document(uid).update({
              'membershipTier': 'premium',
              'paymentId': stripe_customer_id,
              'membershipStartDate': now,
              'membershipEndDate': end_date,
              'updatedAt': now
          })
          
          # 支払い記録作成
          db.collection('payments').add({
              'userId': uid,
              'stripeCustomerId': stripe_customer_id,
              'stripeSubscriptionId': subscription.id,
              'plan': plan_type,
              'amount': 800 if plan_type == 'monthly' else 8000,
              'currency': 'jpy',
              'status': 'active',
              'startDate': now,
              'endDate': end_date,
              'createdAt': now,
              'updatedAt': now
          })
          
          return {
              'success': True,
              'subscriptionId': subscription.id
          }
          
      except Exception as e:
          print(f'アップグレードエラー: {str(e)}')
          return {
              'error': 'internal',
              'message': '有料会員へのアップグレードに失敗しました'
          }, 500
  ```

#### 論文関連
- **uploadPaper**: 論文PDFアップロード・保存
  ```python
  import base64
  import mimetypes
  from typing import Dict, Any
  from google.cloud import storage
  from firebase_admin import auth, firestore, storage as firebase_storage
  import functions_framework
  from datetime import datetime
  import uuid

  @functions_framework.http
  def upload_paper(request) -> Dict[str, Any]:
      """論文PDFをアップロードする関数"""
      try:
          # 認証確認
          auth_header = request.headers.get('Authorization', '')
          if not auth_header.startswith('Bearer '):
              return {
                  'error': 'unauthenticated',
                  'message': '認証が必要です'
              }, 401
          
          token = auth_header.split('Bearer ')[1]
          decoded_token = auth.verify_id_token(token)
          uid = decoded_token['uid']
          
          # リクエストデータ取得
          request_json = request.get_json()
          file_base64 = request_json.get('fileBase64')
          file_name = request_json.get('fileName')
          file_size = request_json.get('fileSize')
          
          # バリデーション
          if file_size > 20 * 1024 * 1024:  # 20MB制限
              return {
                  'error': 'invalid-argument',
                  'message': 'ファイルサイズは20MB以下にしてください'
              }, 400
          
          # Base64デコード
          file_data = base64.b64decode(file_base64.split(',')[1])
          
          # MIMEタイプ確認
          mime_type = mimetypes.guess_type(file_name)[0]
          if mime_type != 'application/pdf':
              return {
                  'error': 'invalid-argument',
                  'message': 'アップロードできるのはPDFファイルのみです'
              }, 400
          
          # Firestore/Storageクライアント
          db = firestore.client()
          bucket = firebase_storage.bucket()
          
          # 一意のファイル名生成
          paper_id = str(uuid.uuid4())
          storage_path = f'papers/{uid}/{paper_id}.pdf'
          
          # Cloud Storageにアップロード
          blob = bucket.blob(storage_path)
          blob.upload_from_string(
              file_data,
              content_type='application/pdf',
              metadata={
                  'originalName': file_name
              }
          )
          
          # 署名付きURL生成
          signed_url = blob.generate_signed_url(
              version='v4',
              expiration=datetime(2500, 1, 1),  # 長期間有効
              method='GET'
          )
          
          # Firestoreにメタデータ保存
          now = datetime.utcnow()
          db.collection('papers').document(paper_id).set({
              'id': paper_id,
              'uploaderId': uid,
              'title': file_name.replace('.pdf', ''),
              'fileUrl': signed_url,
              'fileSize': file_size,
              'processingStatus': 'pending',
              'createdAt': now,
              'updatedAt': now
          })
          
          # 非同期でPDF解析処理をトリガー
          analyze_pdf_background(paper_id)
          
          return {
              'success': True,
              'paperId': paper_id,
              'fileUrl': signed_url
          }
          
      except Exception as e:
          print(f'論文アップロードエラー: {str(e)}')
          return {
              'error': 'internal',
              'message': 'PDFのアップロードに失敗しました'
          }, 500

  def analyze_pdf_background(paper_id: str) -> None:
      """非同期でPDF解析処理をキューに追加"""
      from google.cloud import tasks_v2
      
      client = tasks_v2.CloudTasksClient()
      parent = client.queue_path('your-project-id', 'your-location', 'paper-analysis-queue')
      
      task = {
          'http_request': {
              'http_method': tasks_v2.HttpMethod.POST,
              'url': 'https://your-function-url/analyzePaper',
              'headers': {
                  'Content-Type': 'application/json'
              },
              'body': json.dumps({'paperId': paper_id}).encode()
          }
      }
      
      client.create_task(parent=parent, task=task)
  ```

- **analyzePaper**: Vertex AIによる論文解析
  ```python
  import functions_framework
  import json
  import os
  import tempfile
  from datetime import datetime
  from typing import Dict, Any, List
  from google.cloud import storage, vision, aiplatform
  from firebase_admin import firestore, storage as firebase_storage
  import fitz  # PyMuPDF for PDF processing
  
  @functions_framework.http
  def analyze_paper(request) -> Dict[str, Any]:
      """論文PDFを解析する関数"""
      try:
          # リクエストデータ取得
          request_json = request.get_json()
          paper_id = request_json.get('paperId')
          
          if not paper_id:
              return {
                  'error': 'invalid-argument',
                  'message': 'paperIdが必要です'
              }, 400
          
          # Firestore/Storageクライアント
          db = firestore.client()
          storage_client = storage.Client()
          bucket = firebase_storage.bucket()
          
          # 処理中ステータスに更新
          db.collection('papers').document(paper_id).update({
              'processingStatus': 'processing',
              'updatedAt': datetime.utcnow()
          })
          
          # 論文データ取得
          paper_doc = db.collection('papers').document(paper_id).get()
          if not paper_doc.exists:
              raise ValueError('論文データが見つかりません')
          
          paper_data = paper_doc.to_dict()
          
          # PDFファイルをローカルに一時保存
          with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_pdf:
              blob = bucket.blob(f'papers/{paper_data["uploaderId"]}/{paper_id}.pdf')
              blob.download_to_filename(temp_pdf.name)
              pdf_path = temp_pdf.name
          
          try:
              # PDFからテキスト抽出
              extracted_text = extract_text_from_pdf(pdf_path)
              
              # 図表抽出
              figures = extract_figures_from_pdf(pdf_path, paper_id, vision.ImageAnnotatorClient())
              
              # Vertex AIによる解析
              vertexai = aiplatform.VertexAI(
                  project='your-project-id',
                  location='us-central1'
              )
              
              model = vertexai.get_model('gemini-2.0-flash')
              
              # 論文要約生成
              summary_prompt = f"""
              以下は学術論文のテキストです。論文の重要なポイントを抽出し、以下の形式で回答してください:
              1. 要約（200語以内）
              2. 重要ポイント（箇条書きで5つ）
              3. 研究の意義（100語以内）
              4. 関連分野・トピック（5つ）
              
              論文テキスト:
              {extracted_text[:15000]}  # トークン制限を考慮
              """
              
              response = model.predict(summary_prompt)
              summary_text = response.text
              
              # 解析結果をパース
              analysis = parse_ai_analysis(summary_text)
              
              # 解析結果をFirestoreに保存
              db.collection('papers').document(paper_id).update({
                  'metadata': {
                      'extractedText': extracted_text,
                      'figures': figures
                  },
                  'aiAnalysis': analysis,
                  'processingStatus': 'completed',
                  'updatedAt': datetime.utcnow()
              })
              
              return {
                  'success': True,
                  'message': '論文の解析が完了しました'
              }
              
          except Exception as e:
              # エラー情報を保存
              error_info = {
                  'timestamp': datetime.utcnow(),
                  'message': str(e),
                  'code': type(e).__name__
              }
              
              db.collection('papers').document(paper_id).update({
                  'processingStatus': 'failed',
                  'errorLogs': firestore.ArrayUnion([error_info]),
                  'updatedAt': datetime.utcnow()
              })
              
              raise e
              
          finally:
              # 一時ファイル削除
              if os.path.exists(pdf_path):
                  os.unlink(pdf_path)
          
      except Exception as e:
          print(f'論文解析エラー: {str(e)}')
          return {
              'error': 'internal',
              'message': '論文の解析に失敗しました'
          }, 500

  def extract_text_from_pdf(pdf_path: str) -> str:
      """PDFからテキストを抽出する関数"""
      text = []
      with fitz.open(pdf_path) as doc:
          for page in doc:
              text.append(page.get_text())
      return '\n'.join(text)

  def extract_figures_from_pdf(pdf_path: str, paper_id: str, vision_client: vision.ImageAnnotatorClient) -> List[Dict[str, Any]]:
      """PDFから図表を抽出する関数"""
      figures = []
      with fitz.open(pdf_path) as doc:
          for page_num, page in enumerate(doc):
              # 図表の領域を検出
              images = page.get_images(full=True)
              for img_idx, img in enumerate(images):
                  try:
                      # 画像データ取得
                      xref = img[0]
                      base_image = doc.extract_image(xref)
                      image_bytes = base_image["image"]
                      
                      # Vision APIで画像解析
                      image = vision.Image(content=image_bytes)
                      response = vision_client.document_text_detection(image=image)
                      
                      # キャプション抽出（画像周辺のテキスト）
                      caption = extract_caption_from_page(page, img[1])  # img[1]は画像の位置情報
                      
                      # Storage保存用のパス
                      image_path = f'figures/{paper_id}/figure_{page_num}_{img_idx}.{base_image["ext"]}'
                      
                      # Cloud Storageに保存
                      bucket = firebase_storage.bucket()
                      blob = bucket.blob(image_path)
                      blob.upload_from_string(
                          image_bytes,
                          content_type=f'image/{base_image["ext"]}'
                      )
                      
                      # 署名付きURL生成
                      url = blob.generate_signed_url(
                          version='v4',
                          expiration=datetime(2500, 1, 1),
                          method='GET'
                      )
                      
                      figures.append({
                          'id': f'figure_{page_num}_{img_idx}',
                          'caption': caption,
                          'imageUrl': url,
                          'page': page_num + 1,
                          'importance': calculate_importance_score(caption)  # キャプションから重要度を計算
                      })
                      
                  except Exception as e:
                      print(f'図表抽出エラー: {str(e)}')
                      continue
                      
      return figures

  def parse_ai_analysis(summary_text: str) -> Dict[str, Any]:
      """AI解析結果をパースする関数"""
      # 実装は省略（テキストから構造化データを抽出）
      pass

  def calculate_importance_score(caption: str) -> int:
      """図表の重要度スコアを計算する関数"""
      # 実装は省略（キャプションのキーワード分析などでスコアを算出）
      pass
  ```

- **extractFigures**: 論文から図表抽出
- **listUserPapers**: ユーザーのアップロード論文一覧取得

#### 新聞関連
- **createNewspaper**: 新聞生成開始
  ```python
  import functions_framework
  import json
  import uuid
  from datetime import datetime
  from typing import Dict, Any
  from firebase_admin import auth, firestore
  from google.cloud import tasks_v2
  
  @functions_framework.http
  def create_newspaper(request) -> Dict[str, Any]:
      """新聞を生成する関数"""
      try:
          # 認証確認
          auth_header = request.headers.get('Authorization', '')
          if not auth_header.startswith('Bearer '):
              return {
                  'error': 'unauthenticated',
                  'message': '認証が必要です'
              }, 401
          
          token = auth_header.split('Bearer ')[1]
          decoded_token = auth.verify_id_token(token)
          uid = decoded_token['uid']
          
          # リクエストデータ取得
          request_json = request.get_json()
          paper_ids = request_json.get('paperIds', [])
          template_id = request_json.get('templateId')
          
          # Firestoreクライアント
          db = firestore.client()
          
          # ユーザー情報取得
          user_doc = db.collection('users').document(uid).get()
          if not user_doc.exists:
              return {
                  'error': 'not-found',
                  'message': 'ユーザー情報が見つかりません'
              }, 404
          
          user_data = user_doc.to_dict()
          
          # 無料会員の制限チェック
          if user_data.get('membershipTier') == 'free':
              # 月間生成回数チェック
              if user_data.get('generatedCount', 0) >= 3:
                  return {
                      'error': 'resource-exhausted',
                      'message': '無料会員の月間生成回数上限（3回）に達しました'
                  }, 403
              
              # テンプレート使用可能チェック
              template_doc = db.collection('templates').document(template_id).get()
              template_data = template_doc.to_dict()
              
              if template_data and template_data.get('isPremium'):
                  return {
                      'error': 'permission-denied',
                      'message': 'このテンプレートは有料会員専用です'
                  }, 403
          
          # 論文データ取得
          paper_docs = []
          for paper_id in paper_ids:
              doc = db.collection('papers').document(paper_id).get()
              if doc.exists:
                  paper_docs.append(doc.to_dict())
              else:
                  return {
                      'error': 'not-found',
                      'message': '指定された論文が見つかりません'
                  }, 404
          
          # 新規新聞ID生成
          newspaper_id = str(uuid.uuid4())
          now = datetime.utcnow()
          
          # 初期新聞エントリ作成
          db.collection('newspapers').document(newspaper_id).set({
              'id': newspaper_id,
              'creatorId': uid,
              'title': f'新聞 - {now.strftime("%Y年%m月%d日")}',
              'templateId': template_id,
              'isPublic': False,
              'shareSettings': {
                  'type': 'private',
                  'groupIds': [],
                  'viewCount': 0
              },
              'content': {},  # 初期コンテンツは空
              'customSettings': {
                  'fontFamily': 'default',
                  'colorScheme': 'default'
              },
              'createdAt': now,
              'updatedAt': now
          })
          
          # 無料ユーザーの場合、生成回数を更新
          if user_data.get('membershipTier') == 'free':
              db.collection('users').document(uid).update({
                  'generatedCount': firestore.Increment(1),
                  'updatedAt': now
              })
          
          # 新聞生成タスクをキューに追加
          generate_newspaper_background(newspaper_id, uid, paper_ids, template_id)
          
          return {
              'success': True,
              'newspaperId': newspaper_id
          }
          
      except Exception as e:
          print(f'新聞生成エラー: {str(e)}')
          return {
              'error': 'internal',
              'message': '新聞生成の開始に失敗しました'
          }, 500
  
  def generate_newspaper_background(newspaper_id: str, uid: str, paper_ids: list, template_id: str) -> None:
      """非同期で新聞生成処理をキューに追加"""
      client = tasks_v2.CloudTasksClient()
      parent = client.queue_path('your-project-id', 'your-location', 'newspaper-generation-queue')
      
      payload = {
          'newspaperId': newspaper_id,
          'uid': uid,
          'paperIds': paper_ids,
          'templateId': template_id
      }
      
      task = {
          'http_request': {
              'http_method': tasks_v2.HttpMethod.POST,
              'url': 'https://your-function-url/generateNewspaper',
              'headers': {
                  'Content-Type': 'application/json'
              },
              'body': json.dumps(payload).encode()
          }
      }
      
      client.create_task(parent=parent, task=task)
  ```

- **generateNewspaperContent**: 論文から新聞コンテンツ生成
  ```python
  import functions_framework
  import json
  import random
  from datetime import datetime
  from typing import Dict, Any, List
  from google.cloud import aiplatform
  from firebase_admin import firestore
  import asyncio
  
  @functions_framework.http
  def generate_newspaper(request) -> Dict[str, Any]:
      """新聞コンテンツを生成する関数"""
      try:
          # リクエストデータ取得
          request_json = request.get_json()
          newspaper_id = request_json.get('newspaperId')
          uid = request_json.get('uid')
          paper_ids = request_json.get('paperIds')
          template_id = request_json.get('templateId')
          
          if not all([newspaper_id, uid, paper_ids, template_id]):
              return {
                  'error': 'invalid-argument',
                  'message': '必要なパラメータが不足しています'
              }, 400
          
          # Firestoreクライアント
          db = firestore.client()
          
          # 論文データ取得
          paper_docs = []
          for paper_id in paper_ids:
              doc = db.collection('papers').document(paper_id).get()
              if doc.exists:
                  paper_docs.append(doc.to_dict())
          
          if not paper_docs:
              return {
                  'error': 'not-found',
                  'message': '有効な論文データが見つかりません'
              }, 404
          
          # テンプレート情報取得
          template_doc = db.collection('templates').document(template_id).get()
          if not template_doc.exists:
              return {
                  'error': 'not-found',
                  'message': 'テンプレートが見つかりません'
              }, 404
          
          template_data = template_doc.to_dict()
          
          # Vertex AI初期化
          aiplatform.init(project='your-project-id', location='us-central1')
          model = aiplatform.Model.load_from_model_name('gemini-2.0-flash')
          
          # 論文間の関連性分析
          paper_summaries = '\n\n'.join([
              f"論文タイトル: {p.get('title', '')}\n"
              f"要約: {p.get('aiAnalysis', {}).get('summary', '')}\n"
              f"重要ポイント: {', '.join(p.get('aiAnalysis', {}).get('keypoints', []))}"
              for p in paper_docs
          ])
          
          relationship_prompt = f"""
          以下は複数の学術論文の要約です。これらの論文間の関連性を分析し、新聞記事として構成するための
          重要度順位付けと関連性マップを作成してください。
          
          {paper_summaries}
          
          以下の形式で出力してください:
          1. メイン記事として扱うべき論文（最も重要または中心的な論文）
          2. サブ記事として扱うべき論文順位
          3. 論文間の関連性マップ（どの論文がどのように関連しているか）
          4. 全体を通した大きなテーマまたは研究領域
          """
          
          relationship_result = model.predict(relationship_prompt)
          main_paper_index = determine_main_paper(relationship_result.text, paper_docs)
          main_paper = paper_docs[main_paper_index]
          sub_papers = [p for i, p in enumerate(paper_docs) if i != main_paper_index]
          
          # メイン記事生成
          main_article_prompt = f"""
          あなたは優れた科学ジャーナリストです。以下の学術論文を一般読者向けの新聞記事に変換してください。
          
          論文タイトル: {main_paper.get('title')}
          著者: {', '.join(main_paper.get('authors', ['不明']))}
          要約: {main_paper.get('aiAnalysis', {}).get('summary', '')}
          重要ポイント: {'\n'.join(main_paper.get('aiAnalysis', {}).get('keypoints', []))}
          
          以下の形式で新聞記事を作成してください:
          1. 見出し（20文字以内、インパクトのある表現）
          2. 小見出し（30文字以内）
          3. 本文（500字程度、一般読者にもわかりやすく研究の重要性を伝える内容）
          
          新聞記事のスタイル:
          - 最初の段落は研究の重要性を強調
          - 専門用語は極力避け、必要な場合は簡潔に説明を加える
          - 研究の社会的意義や将来の応用についても言及
          - 縦書きの新聞記事として読みやすい段落構成
          """
          
          main_article_result = model.predict(main_article_prompt)
          main_article = parse_main_article(main_article_result.text)
          
          # サブ記事生成
          async def generate_sub_article(paper: Dict[str, Any]) -> Dict[str, Any]:
              sub_article_prompt = f"""
              あなたは優れた科学ジャーナリストです。以下の学術論文を簡潔な新聞記事に変換してください。
              
              論文タイトル: {paper.get('title')}
              著者: {', '.join(paper.get('authors', ['不明']))}
              要約: {paper.get('aiAnalysis', {}).get('summary', '')}
              
              以下の形式で短い記事を作成してください:
              1. 見出し（15文字以内）
              2. 本文（200字程度）
              
              簡潔で一般読者にもわかりやすい内容にしてください。
              """
              
              result = await aiplatform.aio.Model.predict(model, sub_article_prompt)
              return {
                  'headline': extract_headline(result.text),
                  'content': extract_content(result.text),
                  'paperId': paper.get('id'),
                  'imageUrl': paper.get('metadata', {}).get('figures', [{}])[0].get('imageUrl', '')
              }
          
          sub_articles = await asyncio.gather(*[
              generate_sub_article(paper) for paper in sub_papers
          ])
          
          # サイドバーコンテンツ生成
          sidebar_prompt = f"""
          以下の学術論文群から抽出された情報を基に、新聞のサイドバーに掲載する内容を作成してください。
          
          {paper_summaries}
          
          サイドバーには以下を含めてください:
          1. 関連キーワード（5-7つ）
          2. 研究分野の簡単な解説（100字程度）
          3. 今後の研究展望（100字程度）
          
          簡潔で読者の興味を引く内容にしてください。
          """
          
          sidebar_result = model.predict(sidebar_prompt)
          
          # 新聞名生成
          newspaper_name_prompt = f"""
          以下の学術研究分野に関連する架空の専門新聞名を考えてください。
          研究分野: {main_paper.get('aiAnalysis', {}).get('academicField', '学術研究')}
          
          例えば「○○タイムズ」「△△新聞」のような形式で、権威と専門性を感じさせる名前を1つだけ提案してください。
          """
          
          newspaper_name_result = model.predict(newspaper_name_prompt)
          newspaper_name = newspaper_name_result.text.strip()
          
          # 現在の日付
          now = datetime.utcnow()
          date_str = now.strftime('%Y年%m月%d日')
          
          # 新聞コンテンツをFirestoreに保存
          db.collection('newspapers').document(newspaper_id).update({
              'content': {
                  'header': {
                      'newspaperName': newspaper_name,
                      'date': date_str,
                      'issueNumber': f'第{random.randint(1, 1000)}号'
                  },
                  'mainArticle': {
                      'headline': main_article['headline'],
                      'subheadline': main_article['subheadline'],
                      'content': main_article['content'],
                      'imageUrl': main_paper.get('metadata', {}).get('figures', [{}])[0].get('imageUrl', ''),
                      'paperIds': [main_paper.get('id')]
                  },
                  'subArticles': sub_articles,
                  'sidebarContent': sidebar_result.text,
                  'columnContent': generate_column_content(paper_docs),
                  'footer': f'© {now.year} Research News Network. 本紙は学術論文を基に生成されたものです。原論文の権利は各著者に帰属します。'
              },
              'updatedAt': now
          })
          
          # プレビュー画像生成
          generate_preview_image(newspaper_id, template_data.get('layout', {}))
          
          return {
              'success': True,
              'message': '新聞コンテンツが正常に生成されました'
          }
          
      except Exception as e:
          print(f'新聞コンテンツ生成エラー: {str(e)}')
          
          # エラー情報を保存
          try:
              db.collection('newspapers').document(newspaper_id).update({
                  'error': {
                      'message': str(e),
                      'timestamp': datetime.utcnow()
                  },
                  'updatedAt': datetime.utcnow()
              })
          except:
              pass
          
          return {
              'error': 'internal',
              'message': 'コンテンツ生成に失敗しました'
          }, 500
  
  def determine_main_paper(analysis_text: str, papers: List[Dict[str, Any]]) -> int:
      """関連性分析の結果から最も重要な論文のインデックスを決定する"""
      # 実装は省略
      return 0
  
  def parse_main_article(article_text: str) -> Dict[str, str]:
      """メイン記事のテキストを構造化データに変換"""
      # 実装は省略
      return {
          'headline': '',
          'subheadline': '',
          'content': ''
      }
  
  def extract_headline(text: str) -> str:
      """テキストから見出しを抽出"""
      # 実装は省略
      return ''
  
  def extract_content(text: str) -> str:
      """テキストから本文を抽出"""
      # 実装は省略
      return ''
  
  def generate_column_content(papers: List[Dict[str, Any]]) -> str:
      """論文データからコラム内容を生成"""
      # 実装は省略
      return ''
  
  def generate_preview_image(newspaper_id: str, layout: Dict[str, Any]) -> None:
      """新聞プレビュー画像を生成する"""
      # 実装は省略
      pass
  ```

- **saveNewspaper**: 生成した新聞の保存
- **updateNewspaper**: 新聞内容の更新
- **listUserNewspapers**: ユーザーの新聞一覧取得
- **shareNewspaper**: 新聞の共有設定更新
- **exportToPdf**: 新聞をPDFに変換

#### グループ関連
- **createGroup**: 研究グループ作成
- **updateGroup**: グループ情報更新
- **addGroupMember**: グループにメンバー追加
- **removeGroupMember**: グループからメンバー削除
- **listUserGroups**: ユーザーの所属グループ一覧

#### 決済関連
- **createCheckoutSession**: Stripe決済セッション作成
- **handleSubscriptionUpdate**: サブスクリプション状態更新処理
- **cancelSubscription**: サブスクリプション解約処理

### 4.2 Vertex AI実装詳細

#### 実装アーキテクチャ
Vertex AIの実装は、Cloud Functions上で以下のように構成されています：

```
functions/
└── src/
    └── ai/
        ├── services/          # AIサービスの実装
        │   ├── BaseAIService.ts
        │   ├── PaperAnalysisService.ts
        │   └── NewspaperGenerationService.ts
        ├── prompts/          # プロンプトテンプレート
        │   ├── paper-analysis.txt
        │   └── newspaper-generation.txt
        └── utils/            # ユーティリティ
            ├── error-handling.ts
            └── monitoring.ts
```

Cloud Functionsを使用する主な理由：
1. スケーラビリティ：需要に応じて自動でスケーリング
2. サーバーレス：インフラ管理が不要
3. 非同期処理：長時間実行が必要なAI処理に適している
4. コスト効率：使用した分のみの課金

処理フロー：
1. クライアントからのリクエスト受信
2. Cloud Functions上でVertex AI APIを呼び出し
3. 結果をFirestoreに保存
4. クライアントに処理完了を通知

#### AIサービスクラス設計
```typescript
// src/ai/services/BaseAIService.ts
abstract class BaseAIService {
  protected genAI: VertexAI;
  protected model: GenerativeModel;
  
  constructor(projectId: string, location: string) {
    this.genAI = new VertexAI({project: projectId, location});
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  }
  
  protected async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    initialDelay: number = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (!this.isRetryableError(error)) throw error;
        await this.delay(initialDelay * Math.pow(2, i));
      }
    }
    
    throw lastError;
  }
  
  private isRetryableError(error: any): boolean {
    const retryableErrors = [
      'RESOURCE_EXHAUSTED',
      'UNAVAILABLE',
      'DEADLINE_EXCEEDED'
    ];
    return retryableErrors.includes(error.code);
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// src/ai/services/PaperAnalysisService.ts
class PaperAnalysisService extends BaseAIService {
  constructor(projectId: string, location: string) {
    super(projectId, location);
  }
  
  async analyzePaper(paperContent: string): Promise<PaperAnalysis> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('paper-analysis');
      const formattedPrompt = this.formatPrompt(prompt, { content: paperContent });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseAnalysisResult(result.response.text());
    });
  }
  
  async generateNewsSummary(analysis: PaperAnalysis): Promise<NewsSummary> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('news-summary');
      const formattedPrompt = this.formatPrompt(prompt, { analysis });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseNewsSummary(result.response.text());
    });
  }
  
  private async loadPromptTemplate(templateName: string): Promise<string> {
    // プロンプトテンプレートをファイルから読み込む
    const templatePath = path.join(__dirname, '../prompts', `${templateName}.txt`);
    return fs.promises.readFile(templatePath, 'utf-8');
  }
}

// src/ai/services/NewspaperGenerationService.ts
class NewspaperGenerationService extends BaseAIService {
  constructor(projectId: string, location: string) {
    super(projectId, location);
  }
  
  async generateNewspaper(papers: PaperAnalysis[]): Promise<NewspaperContent> {
    return this.withRetry(async () => {
      // 複数の論文を新聞形式にまとめる
      const prompt = await this.loadPromptTemplate('newspaper-generation');
      const formattedPrompt = this.formatPrompt(prompt, { papers });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseNewspaperContent(result.response.text());
    });
  }
  
  async generateHeadlines(content: string): Promise<Headlines> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('headline-generation');
      const result = await this.model.generateContent(prompt);
      return this.parseHeadlines(result.response.text());
    });
  }
}
```

#### エラーハンドリング実装
```typescript
// src/ai/utils/error-handling.ts
export class AIServiceError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'AIServiceError';
  }
  
  static fromVertexError(error: any): AIServiceError {
    // Vertex AIのエラーを標準化されたエラーに変換
    const errorMap: { [key: string]: string } = {
      'RESOURCE_EXHAUSTED': 'RATE_LIMIT_EXCEEDED',
      'INVALID_ARGUMENT': 'INVALID_INPUT',
      'FAILED_PRECONDITION': 'SERVICE_ERROR',
      'UNAVAILABLE': 'SERVICE_UNAVAILABLE'
    };
    
    return new AIServiceError(
      errorMap[error.code] || 'UNKNOWN_ERROR',
      error.message || 'AI処理中にエラーが発生しました',
      error.details
    );
  }
}

// src/ai/utils/monitoring.ts
export class AIMonitoring {
  static async logAPICall(
    service: string,
    operation: string,
    duration: number,
    success: boolean,
    error?: Error
  ) {
    await admin.firestore().collection('ai-metrics').add({
      service,
      operation,
      duration,
      success,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : null,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
  }
}
```

#### 論文解析プロンプト設計
Vertex AI Gemini 2.0 Flashに対して適切な指示を与えるためのプロンプト設計：

1. **論文構造理解プロンプト**
```
あなたは学術論文専門のAIアシスタントです。以下のPDFから抽出されたテキストを解析し、論文の構造を特定してください。

[抽出テキスト]

以下の情報を特定して、JSON形式で出力してください:
1. 論文タイトル
2. 著者リスト
3. 所属機関
4. アブストラクト
5. キーワード
6. 章・セクション構造（階層的に）
7. 図表の参照箇所とキャプション
8. 結論
9. 参考文献
```

2. **要約生成プロンプト**
```
以下の学術論文を要約してください。専門家ではない読者にも理解できる平易な言葉で、研究の重要性と主要な発見を強調してください。

[論文テキスト]

以下の形式で回答してください:
1. 要約（200語以内）：研究の背景、目的、方法、結果、意義を含める
2. 重要ポイント（5項目）：箇条書きで研究の最も重要な側面を説明
3. 研究の意義（100語以内）：この研究が分野や社会にどのような影響を与えるか
4. 関連トピック（5つ）：この研究に関連する他の研究分野やトピック
```

3. **新聞スタイル変換プロンプト**
```
あなたは科学ジャーナリストです。以下の学術論文の内容を、一般の新聞読者向けの記事に変換してください。

論文タイトル: [タイトル]
著者: [著者リスト]
要約: [要約]

以下の新聞記事形式で執筆してください:
1. 見出し：インパクトがあり、研究の本質を捉えた20字以内の見出し
2. リード文：研究の重要性を強調した導入部（50字程度）
3. 本文：研究内容を平易に説明し、専門用語を避けた説明（400字程度）
4. 図表説明：主要な図表の内容を簡潔に説明（必要な場合のみ）
5. まとめ：研究の意義や今後の展望（50字程度）

新聞記事として、読者の興味を引き、最後まで読ませる構成にしてください。
```

#### AIモデル選定と利用方針

1. **メインAI処理**: Vertex AI Gemini 2.0 Flash
   - トークン制限: 1リクエストあたり32,000トークン
   - レスポンス速度: 低レイテンシ（平均1-3秒）
   - 使用用途:
     - 論文構造解析
     - 要約生成
     - 新聞記事スタイル変換
     - 関連性分析
   - 設定パラメータ:
     - temperature: 0.2（事実に基づく正確な出力）
     - topK: 40
     - topP: 0.8

2. **長文解析**: チャンク分割アプローチ
   - 論文をセクション単位でチャンク分割（最大8,000トークン）
   - チャンクごとに解析し、結果を統合
   - 重複情報の除去とマージアルゴリズム

3. **図表処理**: Vertex AI OCR + Vision API
   - 図表領域の検出と抽出
   - 図表内のテキスト認識
   - キャプションと図表の関連付け

4. **図表処理**:
   - 論文PDFからの図表抽出処理
   - 抽出できない図表は使用しない方針
   - 元論文の図表を改変せず正確に表示

## 5. UI/UX詳細設計

### 5.1 Reactアーキテクチャ設計
- **コンポーネント設計アプローチ**: Atomic Design手法
  - **Atoms**: ボタン、入力フィールド、アイコン等の基本要素
  - **Molecules**: フォームグループ、カード、ナビゲーション項目等
  - **Organisms**: ヘッダー、フッター、サイドバー、フォーム等
  - **Templates**: ページレイアウトの枠組み
  - **Pages**: 実際のページコンポーネント

- **コンポーネント構造例**:
```
src/
├── components/          # 共通コンポーネント
│   ├── ui/             # UIコンポーネント
│   │   ├── atoms/
│   │   │   ├── Button/
│   │   │   │   ├── Button.tsx
│   │   │   │   ├── Button.styles.ts
│   │   │   │   └── Button.test.tsx
│   │   │   ├── Input/
│   │   │   └── Typography/
│   │   ├── molecules/
│   │   │   ├── FormField/
│   │   │   ├── NewspaperCard/
│   │   │   └── PaperItem/
│   │   └── organisms/
│   │       ├── Header/
│   │       ├── NewspaperEditor/
│   │       └── PaperUploader/
│   └── features/       # 機能コンポーネント
│       ├── auth/
│       │   ├── LoginForm/
│       │   └── RegisterForm/
│       └── newspaper/
│           ├── TemplateSelector/
│           └── ContentEditor/
├── routes/             # ルーティング設定
│   ├── auth/
│   │   ├── Login.tsx
│   │   └── Register.tsx
│   ├── papers/
│   │   ├── PaperList.tsx
│   │   └── PaperDetail.tsx
│   ├── newspapers/
│   │   ├── NewspaperList.tsx
│   │   ├── NewspaperCreate.tsx
│   │   └── NewspaperDetail.tsx
│   └── index.tsx
├── services/           # APIサービス
│   ├── api.ts
│   ├── auth.service.ts
│   ├── paper.service.ts
│   └── newspaper.service.ts
├── hooks/             # カスタムフック
│   ├── useAuth.ts
│   ├── usePaper.ts
│   └── useNewspaper.ts
├── store/             # Redux store
│   ├── slices/
│   │   ├── authSlice.ts
│   │   ├── paperSlice.ts
│   │   └── newspaperSlice.ts
│   └── store.ts
├── utils/             # ユーティリティ
│   ├── api.ts
│   ├── validation.ts
│   └── helpers.ts
├── styles/           # グローバルスタイル
│   ├── theme.ts
│   └── global.ts
├── types/            # 型定義
│   ├── api.ts
│   ├── paper.ts
│   └── newspaper.ts
├── config/           # 設定ファイル
│   ├── constants.ts
│   └── routes.ts
└── App.tsx          # アプリケーションルート
```

## 6. 新聞レイアウト詳細

### 6.1 基本レイアウト構造
実際の新聞（日本教育新聞など）と同様のレイアウト構造を採用します。特に日本の新聞の特徴である縦書きレイアウトと複数カラム構成、階層的な見出し構造を忠実に再現します。

```
┌─────────────────────────────────────────────────────────────────────────┐
│ ┌───────┐ ┌─────────────────────────────┐ ┌───────────────┐ ┌─────────┐│
│ │号数   │ │      新聞名・日付・曜日     │ │     題字     │ │ヘッダー右││
│ └───────┘ └─────────────────────────────┘ └───────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────┐ ┌─────────┐ ┌─────────────┐│
│ │                                         │ │見出し小 │ │             ││
│ │          主見出し（太ゴシック体）        │ ├─────────┤ │             ││
│ │                                         │ │         │ │             ││
│ ├─────────────────────────────────────────┤ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │   人物  │ │   右カラム  ││
│ │    │    │    │    │    │    │    │     │ │   写真  │ │    記事    ││
│ │    │    │    │    │    │    │    │     │ │         │ │  （縦書き） ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ メ │ イ │ ン │ 記 │ 事 │ 本 │ 文 │     │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ （ │ 縦 │ 書 │ き │ ・ │ 複 │ 数 │ カ   │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ ラ │ ム │ ） │    │    │    │    │     │ ├─────────┤ │             ││
│ │    │    │    │    │    │    │    │     │ │ 小見出し │ │             ││
│ │    │    │    │    │    │    │    │     │ │（網掛け）│ │             ││
│ └─────────────────────────────────────────┘ └─────────┘ └─────────────┘│
├─────────────────────────────────────────────┬─────────────────────────┤
│ ┌─────────────────────────────────────────┐ │ ┌─────────┐ ┌─────────┐ │
│ │             │                           │ │ │         │ │         │ │
│ │  中見出し   │    下部記事（縦書き）      │ │ │ QRコード │ │  広告枠  │ │
│ │             │                           │ │ │         │ │         │ │
│ └─────────────────────────────────────────┘ │ └─────────┘ └─────────┘ │
├─────────────────────────────────────────────┼─────────────────────────┤
│ ┌─────────────────────────┐ ┌─────────────┐ │ ┌───────────────────────┐│
│ │                         │ │             │ │ │                       ││
│ │     左下部記事          │ │  図表/写真  │ │ │      右下部記事       ││
│ │    （縦書き）           │ │             │ │ │     （縦書き）        ││
│ └─────────────────────────┘ └─────────────┘ │ └───────────────────────┘│
└─────────────────────────────────────────────┴─────────────────────────┘
```


## 8. デプロイメント・運用戦略

### 8.0 プロンプトテンプレート管理
```
functions/
└── src/
    └── ai/
        └── prompts/
            ├── paper-analysis.txt          # 論文解析用プロンプト
            ├── news-summary.txt           # ニュース要約用プロンプト
            ├── newspaper-generation.txt    # 新聞生成用プロンプト
            └── headline-generation.txt     # 見出し生成用プロンプト
```

各プロンプトファイルの内容例：

```txt
// paper-analysis.txt
システム: あなたは学術論文を解析する専門家です。以下の論文から重要な要素を抽出し、構造化された形式で出力してください。

入力: 
${paperContent}

必要な出力形式:
{
  "title": "論文タイトル",
  "authors": ["著者1", "著者2"],
  "abstract": "要約（400文字以内）",
  "keywords": ["キーワード1", "キーワード2"],
  "mainFindings": [
    "主要な発見1",
    "主要な発見2"
  ],
  "significance": "研究の意義（200文字以内）",
  "academicField": "該当する学術分野"
}

制約条件:
- 専門用語は可能な限り平易な表現に置き換える
- 重要な数値データは保持する
- 研究の新規性・独自性を明確に示す
```

```txt
// newspaper-generation.txt
システム: あなたは科学ジャーナリストです。提供された論文の解析結果を、一般読者向けの新聞記事に変換してください。

入力:
${paperAnalysis}

必要な出力形式:
{
  "headline": {
    "main": "メイン見出し（20文字以内）",
    "sub": "サブ見出し（30文字以内）"
  },
  "content": {
    "lead": "リード文（100文字以内）",
    "body": "本文（1000文字以内）",
    "conclusion": "結論（100文字以内）"
  },
  "sideInfo": {
    "keywords": ["キーワード1", "キーワード2"],
    "relatedTopics": ["関連トピック1", "関連トピック2"],
    "futureImplications": "今後の展望（100文字以内）"
  }
}

制約条件:
- 一般読者を想定し、平易な表現を使用
- 研究の社会的意義を強調
- 縦書きでの読みやすさを考慮
- 具体的な例や比喩を活用
```

この構造により：
1. プロンプトの一元管理が可能
2. バージョン管理とプロンプトの改善追跡が容易
3. 異なる言語やスタイルへの対応が柔軟
4. プロンプトの再利用と一貫性の維持が可能
