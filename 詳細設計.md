# 論文ベース新聞一面生成システム 詳細設計書（改訂版）

## 1. システム概要
本システムは学術論文をAIで解析し、新聞一面形式に自動変換するWebアプリケーションです。研究者間の情報共有や一般の方々への研究成果の可視化を目的としています。

### 1.1 システムアーキテクチャ
- **クライアント-サーバー型アーキテクチャ**
  - フロントエンド: React/TypeScriptによるSPA
  - バックエンド: Firebase (Firestore, Functions, Authentication)
  - AI処理: Vertex AI Gemini 2.0 Flash
  - PDF処理: React-PDF, PDFKit
  - 決済処理: Stripe API

### 1.2 全体構成図
```
┌─────────────┐     ┌───────────────┐     ┌─────────────────┐
│             │     │               │     │                 │
│ クライアント  │◄────►│ Firebase     │◄────►│ Vertex AI       │
│ (React SPA) │     │ (BaaS)       │     │ Gemini 2.0 Flash  │
│             │     │               │     │                 │
└─────────────┘     └───────────────┘     └─────────────────┘
                          ▲
                          │
                          ▼
                    ┌──────────────┐
                    │              │
                    │ Stripe API   │
                    │ (決済処理)    │
                    │              │
                    └──────────────┘
```

## 2. 技術スタック詳細

### 2.1 フロントエンド
- **フレームワーク**: React 18.x
- **言語**: TypeScript 5.x
- **状態管理**: Redux Toolkit
- **ルーティング**: React Router 6.x
- **UI/スタイリング**:
  - Material UI v5.x
  - Emotion (CSS-in-JS)
  - Material Icons
- **フォーム管理**: React Hook Form + Zod (バリデーション)
- **PDF生成/操作**: React-PDF, PDFKit
- **グラフ/可視化**: D3.js
- **HTTP通信**: Axios
- **テスト**: Jest, React Testing Library
- **ビルドツール**: Vite
- **コンポーネント設計**: Atomic Design手法

### 2.2 バックエンド
- **プラットフォーム**: Firebase
  - **データベース**: Firestore
  - **ストレージ**: Firebase Storage
  - **認証**: Firebase Authentication
  - **サーバーレス関数**: Firebase Functions (Node.js 18.x)
  - **ホスティング**: Firebase Hosting
- **API通信**:
  - RESTful API設計
  - JSON形式でのデータ交換
- **バッチ処理**: Cloud Scheduler + Cloud Functions
- **キャッシュ戦略**: Firebase Cache Control

### 2.3 AI/ML
- **論文解析**: Vertex AI Gemini 2.0 Flash
  - テキスト解析・要約
  - 関連性分析
  - 見出し・記事生成
  - **プロンプト設計**:
    - 体系的なプロンプトテンプレート
    - 論文構造認識プロンプト
    - 新聞スタイル変換プロンプト
  - **コンテキスト管理**:
    - トークン最適化
    - 重要情報抽出戦略
- **画像処理**:
  - OCR処理 (論文PDFからのテキスト抽出)
  - 論文からの図表抽出処理
  - テーブル変換・正規化処理

### 2.4 インフラ
- **クラウド**: Google Cloud Platform
  - **計算リソース**: 標準Compute Engineインスタンス (e2-standard-4)
  - **スケーリング**: 自動スケーリングルール設定
  - **リージョン設定**: asia-northeast1 (東京)
- **CI/CD**: GitHub Actions
  - **テスト・デプロイパイプライン**
  - **環境分離**: 開発/ステージング/本番
- **監視/ロギング**: Firebase Analytics, Google Cloud Monitoring
  - **アラート設定**: エラー率、レスポンスタイム閾値
  - **ログ集約**: Cloud Logging
- **バックアップ**: 自動日次バックアップ (GCS)
  - **リテンション期間**: 30日間
  - **復旧テスト**: 月次実施

## 3. データベース設計

### 3.1 Firestoreコレクション設計

#### users
```
{
  uid: string (PK),  // Firebase Authenticationから生成されるID
  email: string,
  displayName: string,
  profileImageUrl: string,
  membershipTier: string,  // "free" | "premium"
  membershipStartDate: timestamp,
  membershipEndDate: timestamp,
  paymentId: string,  // Stripe顧客ID
  generatedCount: number,  // 生成回数カウント（無料会員用）
  savedNewspapersCount: number,  // 保存した新聞数（無料会員用）
  createdAt: timestamp,
  updatedAt: timestamp,
  lastLoginAt: timestamp,
  preferredLanguage: string,  // "ja" | "en" | "zh" (多言語対応用)
  settings: {
    notifications: boolean,
    theme: string  // "light" | "dark" | "system"
  }
}
```

#### newspapers
```
{
  id: string (PK),
  creatorId: string (FK -> users.uid),
  title: string,
  templateId: string,
  isPublic: boolean,
  shareSettings: {
    type: string,  // "private" | "group" | "public"
    groupIds: string[],  // 共有するグループIDリスト
    viewCount: number,  // 閲覧数カウント
    shareUrl: string  // 共有用一意URL
  },
  content: {
    header: {
      newspaperName: string,
      date: string,
      issueNumber: string
    },
    mainArticle: {
      headline: string,
      subheadline: string,
      content: string,
      imageUrl: string,
      paperIds: string[]  // 関連論文ID
    },
    subArticles: [
      {
        headline: string,
        content: string,
        imageUrl: string,
        paperId: string
      }
    ],
    sidebarContent: string,
    columnContent: string,
    adContent: string,  // 無料会員用広告
    footer: string
  },
  customSettings: {
    fontFamily: string,
    colorScheme: string,
    logoUrl: string
  },
  exportHistory: [
    {
      type: string,  // "pdf" | "png" | "print"
      url: string,  // 生成ファイルへのパス
      createdAt: timestamp
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### papers
```
{
  id: string (PK),
  uploaderId: string (FK -> users.uid),
  title: string,
  authors: string[],
  journal: string,
  publicationDate: string,
  doi: string,
  fileUrl: string,  // Storage内のPDFパス
  fileSize: number,
  metadata: {
    abstract: string,
    keywords: string[],
    figures: [
      {
        id: string,
        caption: string,
        imageUrl: string,
        page: number,
        importance: number  // AIによる重要度スコア (0-100)
      }
    ],
    tables: [
      {
        id: string,
        caption: string,
        data: string,  // JSON形式テーブルデータ
        page: number
      }
    ],
    citations: [
      {
        id: string,
        text: string,
        reference: string
      }
    ],
    extractedText: string,  // 抽出されたフルテキスト
  },
  aiAnalysis: {
    summary: string,
    keypoints: string[],
    significance: string,
    relatedTopics: string[],
    academicField: string,
    technicalLevel: string,  // "beginner" | "intermediate" | "advanced"
    aiConfidenceScore: number  // 解析精度の自己評価スコア (0-100)
  },
  processingStatus: string,  // "pending" | "processing" | "completed" | "failed"
  errorLogs: [
    {
      timestamp: timestamp,
      code: string,
      message: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### groups
```
{
  id: string (PK),
  name: string,
  description: string,
  creatorId: string (FK -> users.uid),
  members: [
    {
      userId: string,
      role: string,  // "admin" | "member" | "viewer"
      joinedAt: timestamp,
      lastActivity: timestamp
    }
  ],
  sharedNewspapers: string[],  // 新聞IDリスト
  invitationLinks: [
    {
      id: string,
      url: string,
      expiresAt: timestamp,
      usedCount: number,
      maxUses: number  // 招待制限数
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### templates
```
{
  id: string (PK),
  name: string,
  description: string,
  previewImageUrl: string,
  isPremium: boolean,
  category: string,  // "standard" | "academic" | "magazine" | "tabloid"
  layout: {
    // レイアウト定義（JSON形式）
    // 要素の位置、サイズ、スタイルなど
    version: string,
    components: [
      {
        type: string,
        id: string,
        position: { x: number, y: number },
        size: { width: number, height: number },
        styles: object,
        content: object
      }
    ]
  },
  compatibleLanguages: string[],  // 対応言語リスト
  usageCount: number,  // 使用回数（人気度）
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### payments
```
{
  id: string (PK),
  userId: string (FK -> users.uid),
  stripeCustomerId: string,
  stripeSubscriptionId: string,
  plan: string,  // "monthly" | "yearly"
  amount: number,
  currency: string,
  status: string,  // "active" | "canceled" | "past_due"
  startDate: timestamp,
  endDate: timestamp,
  paymentMethod: {
    type: string,  // "credit_card" | "bank_transfer"
    last4: string,
    brand: string,
    expiryDate: string
  },
  invoices: [
    {
      id: string,
      amount: number,
      status: string,
      paidAt: timestamp,
      receiptUrl: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### systemSettings
```
{
  id: string (PK),
  aiSettings: {
    modelVersion: string,
    maxTokens: number,
    temperatureDefault: number,
    contextWindowSize: number
  },
  freeUserLimits: {
    generationCount: number,  // 月当たりの生成可能回数
    savedNewspaperCount: number,  // 保存可能な新聞数
    exportFormats: string[]  // 利用可能なエクスポート形式
  },
  premiumUserLimits: {
    maxStorageSize: number,  // GB単位
    maxFileSize: number  // MB単位
  },
  maintenanceMode: boolean,
  notificationMessages: [
    {
      id: string,
      message: string,
      severity: string,  // "info" | "warning" | "error"
      startDate: timestamp,
      endDate: timestamp
    }
  ],
  updatedAt: timestamp,
  updatedBy: string
}
```

### 3.2 Firebase Storage構造
```
/papers/{userId}/{paperId}.pdf  // アップロードされた論文PDF
/figures/{paperId}/{figureId}.{ext}  // 論文から抽出された図表
/tables/{paperId}/{tableId}.json  // 論文から抽出されたテーブルデータ
/newspapers/{newspaperId}/preview.png  // 新聞プレビュー画像
/newspapers/{newspaperId}/export.pdf  // エクスポートされたPDF
/newspapers/{newspaperId}/export.png  // エクスポートされたPNG
/logos/{userId}/custom_logo.{ext}  // カスタムロゴ（有料会員）
/templates/{templateId}/preview.png  // テンプレートプレビュー
/system/backups/daily/{date}/  // システムバックアップ
```

### 3.3 データベースインデックス設計
効率的なクエリ処理のために以下のインデックスを設定:

```
// 新聞検索用複合インデックス
- コレクション: newspapers
  フィールド: 
    - creatorId (ASC)
    - createdAt (DESC)

// 共有新聞検索
- コレクション: newspapers
  フィールド:
    - shareSettings.type (ASC)
    - createdAt (DESC)

// 論文検索
- コレクション: papers
  フィールド:
    - uploaderId (ASC)
    - createdAt (DESC)

// グループメンバーシップ
- コレクション: groups
  フィールド:
    - "members.userId" (ASC)
    - createdAt (DESC)
```

## 4. API設計

### 4.1 Firebase Functions API実装詳細

#### 認証関連
- **createUser**: 新規ユーザー登録
  ```typescript
  // 実装概要
  export const createUser = functions.https.onCall(async (data, context) => {
    // バリデーション
    const { email, password, displayName } = data;
    if (!email || !password || !displayName) {
      throw new functions.https.HttpsError('invalid-argument', '必須項目が不足しています');
    }
    
    try {
      // Firebaseユーザー作成
      const userRecord = await admin.auth().createUser({
        email,
        password,
        displayName
      });
      
      // Firestoreにユーザーデータ保存
      await admin.firestore().collection('users').doc(userRecord.uid).set({
        uid: userRecord.uid,
        email,
        displayName,
        membershipTier: 'free',
        generatedCount: 0,
        savedNewspapersCount: 0,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      return { success: true, uid: userRecord.uid };
    } catch (error) {
      console.error('ユーザー作成エラー:', error);
      throw new functions.https.HttpsError('internal', 'ユーザー登録に失敗しました');
    }
  });
  ```

- **updateUserProfile**: ユーザープロファイル更新
- **upgradeToPremi um**: 有料会員へのアップグレード処理
  ```typescript
  // 実装概要
  export const upgradeToPremium = functions.https.onCall(async (data, context) => {
    // 認証確認
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
    }
    
    const uid = context.auth.uid;
    const { paymentMethodId, planType } = data;
    
    try {
      // ユーザーデータ取得
      const userDoc = await admin.firestore().collection('users').doc(uid).get();
      const userData = userDoc.data();
      
      if (!userData) {
        throw new functions.https.HttpsError('not-found', 'ユーザーが見つかりません');
      }
      
      // Stripe顧客作成/取得
      let stripeCustomerId = userData.paymentId;
      if (!stripeCustomerId) {
        const customer = await stripe.customers.create({
          email: userData.email,
          name: userData.displayName,
          payment_method: paymentMethodId,
          invoice_settings: {
            default_payment_method: paymentMethodId
          }
        });
        stripeCustomerId = customer.id;
      }
      
      // サブスクリプション作成
      const priceId = planType === 'monthly' ? PRICE_ID_MONTHLY : PRICE_ID_YEARLY;
      const subscription = await stripe.subscriptions.create({
        customer: stripeCustomerId,
        items: [{ price: priceId }],
        expand: ['latest_invoice.payment_intent']
      });
      
      // ユーザーデータ更新
      const now = admin.firestore.Timestamp.now();
      const endDate = planType === 'monthly' 
        ? new Date(now.toDate().setMonth(now.toDate().getMonth() + 1))
        : new Date(now.toDate().setFullYear(now.toDate().getFullYear() + 1));
        
      await admin.firestore().collection('users').doc(uid).update({
        membershipTier: 'premium',
        paymentId: stripeCustomerId,
        membershipStartDate: now,
        membershipEndDate: admin.firestore.Timestamp.fromDate(endDate),
        updatedAt: now
      });
      
      // 支払い記録作成
      await admin.firestore().collection('payments').add({
        userId: uid,
        stripeCustomerId,
        stripeSubscriptionId: subscription.id,
        plan: planType,
        amount: planType === 'monthly' ? 800 : 8000,
        currency: 'jpy',
        status: 'active',
        startDate: now,
        endDate: admin.firestore.Timestamp.fromDate(endDate),
        createdAt: now,
        updatedAt: now
      });
      
      return { success: true, subscriptionId: subscription.id };
    } catch (error) {
      console.error('アップグレードエラー:', error);
      throw new functions.https.HttpsError('internal', '有料会員へのアップグレードに失敗しました');
    }
  });
  ```

#### 論文関連
- **uploadPaper**: 論文PDFアップロード・保存
  ```typescript
  // 実装概要
  export const uploadPaper = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '2GB'
    })
    .https.onCall(async (data, context) => {
      // 認証確認
      if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
      }
      
      const uid = context.auth.uid;
      const { fileBase64, fileName, fileSize } = data;
      
      // ファイルサイズチェック
      if (fileSize > 20 * 1024 * 1024) { // 20MB制限
        throw new functions.https.HttpsError(
          'invalid-argument', 
          'ファイルサイズは20MB以下にしてください'
        );
      }
      
      try {
        // Base64デコード
        const fileBuffer = Buffer.from(fileBase64.split(',')[1], 'base64');
        
        // PDFバリデーション (MIMEタイプ確認など)
        const fileMime = await fileType.fromBuffer(fileBuffer);
        if (fileMime?.mime !== 'application/pdf') {
          throw new functions.https.HttpsError(
            'invalid-argument', 
            'アップロードできるのはPDFファイルのみです'
          );
        }
        
        // 一意のファイル名生成
        const paperId = admin.firestore().collection('papers').doc().id;
        const storagePath = `papers/${uid}/${paperId}.pdf`;
        
        // Firebase Storageにアップロード
        const bucket = admin.storage().bucket();
        const file = bucket.file(storagePath);
        await file.save(fileBuffer, {
          contentType: 'application/pdf',
          metadata: {
            contentType: 'application/pdf',
            metadata: {
              originalName: fileName
            }
          }
        });
        
        // ダウンロード用URL生成
        const [signedUrl] = await file.getSignedUrl({
          action: 'read',
          expires: '03-01-2500' // 長期間有効
        });
        
        // Firestoreにメタデータ保存
        const paperRef = admin.firestore().collection('papers').doc(paperId);
        await paperRef.set({
          id: paperId,
          uploaderId: uid,
          title: fileName.replace('.pdf', ''),
          fileUrl: signedUrl,
          fileSize: fileSize,
          processingStatus: 'pending', // 処理待ち状態
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 非同期でPDF解析処理をトリガー
        await analyzePDFBackground(paperId);
        
        return {
          success: true,
          paperId,
          fileUrl: signedUrl
        };
      } catch (error) {
        console.error('論文アップロードエラー:', error);
        throw new functions.https.HttpsError('internal', 'PDFのアップロードに失敗しました');
      }
    });
  ```

- **analyzePaper**: Vertex AIによる論文解析
  ```typescript
  // Vertex AI Gemini 2.0 Flash を使用した論文解析処理
  export const analyzePaperTask = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '4GB'
    })
    .tasks.taskQueue.onDispatch(async (data: { paperId: string }) => {
      const { paperId } = data;
      
      try {
        // 処理中ステータスに更新
        await admin.firestore().collection('papers').doc(paperId).update({
          processingStatus: 'processing',
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 論文データ取得
        const paperDoc = await admin.firestore().collection('papers').doc(paperId).get();
        const paperData = paperDoc.data();
        
        if (!paperData) {
          throw new Error('論文データが見つかりません');
        }
        
        // PDFファイルの取得
        const storage = admin.storage();
        const bucket = storage.bucket();
        const filePath = paperData.fileUrl;
        
        // ローカルに一時保存
        const tempLocalPath = `/tmp/${paperId}.pdf`;
        const pdfBuffer = await downloadFile(filePath);
        fs.writeFileSync(tempLocalPath, pdfBuffer);
        
        // PDFからテキスト抽出
        const extractedText = await extractTextFromPDF(tempLocalPath);
        
        // PDFから図表抽出
        const figures = await extractFiguresFromPDF(tempLocalPath, paperId);
        
        // Vertex AI Gemini 2.0 Flashによる解析
        const genAI = new VertexAI({project: 'your-project-id', location: 'us-central1'});
        const geminiModel = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
        
        // 論文要約と重要ポイント抽出
        const summaryPrompt = `
          以下は学術論文のテキストです。論文の重要なポイントを抽出し、以下の形式で回答してください:
          1. 要約（200語以内）
          2. 重要ポイント（箇条書きで5つ）
          3. 研究の意義（100語以内）
          4. 関連分野・トピック（5つ）
          
          論文テキスト:
          ${extractedText.substring(0, 15000)} // トークン制限を考慮
        `;
        
        const summaryResult = await geminiModel.generateContent(summaryPrompt);
        const summaryText = summaryResult.response.text();
        
        // 結果をパースして構造化
        const analysis = parseAIAnalysisResult(summaryText);
        
        // 解析結果をFirestoreに保存
        await admin.firestore().collection('papers').doc(paperId).update({
          metadata: {
            extractedText: extractedText,
            figures: figures,
          },
          aiAnalysis: analysis,
          processingStatus: 'completed',
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 一時ファイル削除
        fs.unlinkSync(tempLocalPath);
        
        return { success: true };
      } catch (error) {
        console.error('論文解析エラー:', error);
        
        // エラー情報を保存
        await admin.firestore().collection('papers').doc(paperId).update({
          processingStatus: 'failed',
          errorLogs: admin.firestore.FieldValue.arrayUnion({
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            message: error.message || '解析処理に失敗しました',
            code: error.code || 'unknown'
          }),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        throw error;
      }
    });
    
  // 非同期タスクキューの起動関数
  async function analyzePDFBackground(paperId: string) {
    const queue = firebase.tasks().getQueue('paper-analysis-queue');
    await queue.enqueue({ paperId });
  }
  ```

- **extractFigures**: 論文から図表抽出
- **listUserPapers**: ユーザーのアップロード論文一覧取得

#### 新聞関連
- **createNewspaper**: 新聞生成開始
  ```typescript
  // 実装概要
  export const createNewspaper = functions.https.onCall(async (data, context) => {
    // 認証確認
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
    }
    
    const uid = context.auth.uid;
    const { paperIds, templateId } = data;
    
    try {
      // ユーザー情報取得
      const userDoc = await admin.firestore().collection('users').doc(uid).get();
      const userData = userDoc.data();
      
      if (!userData) {
        throw new functions.https.HttpsError('not-found', 'ユーザー情報が見つかりません');
      }
      
      // 無料会員の制限チェック
      if (userData.membershipTier === 'free') {
        // 月間生成回数チェック
        if (userData.generatedCount >= 3) {
          throw new functions.https.HttpsError(
            'resource-exhausted', 
            '無料会員の月間生成回数上限（3回）に達しました'
          );
        }
        
        // テンプレート使用可能チェック
        const templateDoc = await admin.firestore().collection('templates').doc(templateId).get();
        const templateData = templateDoc.data();
        
        if (templateData?.isPremium) {
          throw new functions.https.HttpsError(
            'permission-denied', 
            'このテンプレートは有料会員専用です'
          );
        }
      }
      
      // 論文データ取得
      const paperPromises = paperIds.map(id => 
        admin.firestore().collection('papers').doc(id).get()
      );
      const paperDocs = await Promise.all(paperPromises);
      const papers = paperDocs.map(doc => doc.data());
      
      // 論文が見つからない場合のエラー
      if (papers.some(p => !p)) {
        throw new functions.https.HttpsError('not-found', '指定された論文が見つかりません');
      }
      
      // 新規新聞ID生成
      const newspaperId = admin.firestore().collection('newspapers').doc().id;
      
      // 新聞生成タスクをキューに追加
      await generateNewspaperBackground(newspaperId, uid, paperIds, templateId);
      
      // 初期新聞エントリ作成
      await admin.firestore().collection('newspapers').doc(newspaperId).set({
        id: newspaperId,
        creatorId: uid,
        title: `新聞 - ${new Date().toLocaleDateString('ja-JP')}`,
        templateId,
        isPublic: false,
        shareSettings: {
          type: 'private',
          groupIds: [],
          viewCount: 0
        },
        content: {
          // 初期コンテンツは空
        },
        customSettings: {
          fontFamily: 'default',
          colorScheme: 'default'
        },
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // 無料ユーザーの場合、生成回数を更新
      if (userData.membershipTier === 'free') {
        await admin.firestore().collection('users').doc(uid).update({
          generatedCount: admin.firestore.FieldValue.increment(1),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }
      
      return {
        success: true,
        newspaperId
      };
    } catch (error) {
      console.error('新聞生成エラー:', error);
      throw new functions.https.HttpsError('internal', '新聞生成の開始に失敗しました');
    }
  });
  ```

- **generateNewspaperContent**: 論文から新聞コンテンツ生成
  ```typescript
  // 新聞コンテンツ生成タスク
  export const generateNewspaperContentTask = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '4GB'
    })
    .tasks.taskQueue.onDispatch(async (data: { 
      newspaperId: string, 
      uid: string, 
      paperIds: string[], 
      templateId: string 
    }) => {
      const { newspaperId, uid, paperIds, templateId } = data;
      
      try {
        // 対象論文データ取得
        const paperPromises = paperIds.map(id => 
          admin.firestore().collection('papers').doc(id).get()
        );
        const paperDocs = await Promise.all(paperPromises);
        const papers = paperDocs.map(doc => doc.data()).filter(Boolean);
        
        if (papers.length === 0) {
          throw new Error('有効な論文データが見つかりません');
        }
        
        // テンプレート情報取得
        const templateDoc = await admin.firestore().collection('templates').doc(templateId).get();
        const templateData = templateDoc.data();
        
        if (!templateData) {
          throw new Error('テンプレートが見つかりません');
        }
        
        // Vertex AI Gemini 2.0 Flashによる新聞コンテンツ生成
        const genAI = new VertexAI({project: 'your-project-id', location: 'us-central1'});
        const geminiModel = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
        
        // 論文間の関連性分析
        const paperSummaries = papers.map(p => {
          return `論文タイトル: ${p.title}\n要約: ${p.aiAnalysis?.summary || ''}\n重要ポイント: ${p.aiAnalysis?.keypoints?.join(', ') || ''}`;
        }).join('\n\n');
        
        const relationshipPrompt = `
          以下は複数の学術論文の要約です。これらの論文間の関連性を分析し、新聞記事として構成するための重要度順位付けと関連性マップを作成してください。
          
          ${paperSummaries}
          
          以下の形式で出力してください:
          1. メイン記事として扱うべき論文（最も重要または中心的な論文）
          2. サブ記事として扱うべき論文順位
          3. 論文間の関連性マップ（どの論文がどのように関連しているか）
          4. 全体を通した大きなテーマまたは研究領域
        `;
        
        const relationshipResult = await geminiModel.generateContent(relationshipPrompt);
        const relationshipAnalysis = relationshipResult.response.text();
        
        // 関連性分析に基づき、最も重要な論文を特定
        const mainPaperIndex = determineMainPaper(relationshipAnalysis, papers);
        const mainPaper = papers[mainPaperIndex];
        const subPapers = papers.filter((_, index) => index !== mainPaperIndex);
        
        // メイン記事生成
        const mainArticlePrompt = `
          あなたは優れた科学ジャーナリストです。以下の学術論文を一般読者向けの新聞記事に変換してください。
          
          論文タイトル: ${mainPaper.title}
          著者: ${mainPaper.authors?.join(', ') || '不明'}
          要約: ${mainPaper.aiAnalysis?.summary || ''}
          重要ポイント: ${mainPaper.aiAnalysis?.keypoints?.join('\n') || ''}
          
          以下の形式で新聞記事を作成してください:
          1. 見出し（20文字以内、インパクトのある表現）
          2. 小見出し（30文字以内）
          3. 本文（500字程度、一般読者にもわかりやすく研究の重要性を伝える内容）
          
          新聞記事のスタイル:
          - 最初の段落は研究の重要性を強調
          - 専門用語は極力避け、必要な場合は簡潔に説明を加える
          - 研究の社会的意義や将来の応用についても言及
          - 縦書きの新聞記事として読みやすい段落構成
        `;
        
        const mainArticleResult = await geminiModel.generateContent(mainArticlePrompt);
        const mainArticleContent = mainArticleResult.response.text();
        
        // メイン記事結果パース
        const mainArticle = parseMainArticle(mainArticleContent);
        
        // サブ記事生成
        const subArticlesPromises = subPapers.map(async (paper) => {
          const subArticlePrompt = `
            あなたは優れた科学ジャーナリストです。以下の学術論文を簡潔な新聞記事に変換してください。
            
            論文タイトル: ${paper.title}
            著者: ${paper.authors?.join(', ') || '不明'}
            要約: ${paper.aiAnalysis?.summary || ''}
            
            以下の形式で短い記事を作成してください:
            1. 見出し（15文字以内）
            2. 本文（200字程度）
            
            簡潔で一般読者にもわかりやすい内容にしてください。
          `;
          
          const subArticleResult = await geminiModel.generateContent(subArticlePrompt);
          const subArticleContent = subArticleResult.response.text();
          
          return {
            headline: extractHeadline(subArticleContent),
            content: extractContent(subArticleContent),
            paperId: paper.id,
            imageUrl: paper.metadata?.figures?.[0]?.imageUrl || ''
          };
        });
        
        const subArticles = await Promise.all(subArticlesPromises);
        
        // サイドバーコンテンツ生成
        const sidebarPrompt = `
          以下の学術論文群から抽出された情報を基に、新聞のサイドバーに掲載する内容を作成してください。
          
          ${paperSummaries}
          
          サイドバーには以下を含めてください:
          1. 関連キーワード（5-7つ）
          2. 研究分野の簡単な解説（100字程度）
          3. 今後の研究展望（100字程度）
          
          簡潔で読者の興味を引く内容にしてください。
        `;
        
        const sidebarResult = await geminiModel.generateContent(sidebarPrompt);
        const sidebarContent = sidebarResult.response.text();
        
        // 日付とヘッダー情報の生成
        const today = new Date();
        const dateStr = today.toLocaleDateString('ja-JP', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'long'
        });
        
        // 領域名から新聞名を生成
        const newspaperNamePrompt = `
          以下の学術研究分野に関連する架空の専門新聞名を考えてください。
          研究分野: ${mainPaper.aiAnalysis?.academicField || '学術研究'}
          
          例えば「○○タイムズ」「△△新聞」のような形式で、権威と専門性を感じさせる名前を1つだけ提案してください。
        `;
        
        const newspaperNameResult = await geminiModel.generateContent(newspaperNamePrompt);
        const newspaperName = newspaperNameResult.response.text().trim();
        
        // 新聞コンテンツをFirestoreに保存
        await admin.firestore().collection('newspapers').doc(newspaperId).update({
          content: {
            header: {
              newspaperName: newspaperName,
              date: dateStr,
              issueNumber: `第${Math.floor(Math.random() * 1000) + 1}号`
            },
            mainArticle: {
              headline: mainArticle.headline,
              subheadline: mainArticle.subheadline,
              content: mainArticle.content,
              imageUrl: mainPaper.metadata?.figures?.[0]?.imageUrl || '',
              paperIds: [mainPaper.id]
            },
            subArticles: subArticles,
            sidebarContent: sidebarContent,
            columnContent: generateColumnContent(papers),
            footer: `© ${today.getFullYear()} Research News Network. 本紙は学術論文を基に生成されたものです。原論文の権利は各著者に帰属します。`
          },
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // プレビュー画像生成 (HTMLからPNG)
        await generatePreviewImage(newspaperId, templateData.layout);
        
        return {
          success: true,
          message: '新聞コンテンツが正常に生成されました'
        };
      } catch (error) {
        console.error('新聞コンテンツ生成エラー:', error);
        
        // エラー情報を更新
        await admin.firestore().collection('newspapers').doc(newspaperId).update({
          error: {
            message: error.message || 'コンテンツ生成に失敗しました',
            timestamp: admin.firestore.FieldValue.serverTimestamp()
          },
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        throw error;
      }
    });
    
  // 非同期タスクキューの起動関数
  async function generateNewspaperBackground(
    newspaperId: string, 
    uid: string, 
    paperIds: string[], 
    templateId: string
  ) {
    const queue = firebase.tasks().getQueue('newspaper-generation-queue');
    await queue.enqueue({ newspaperId, uid, paperIds, templateId });
  }
  ```

- **saveNewspaper**: 生成した新聞の保存
- **updateNewspaper**: 新聞内容の更新
- **listUserNewspapers**: ユーザーの新聞一覧取得
- **shareNewspaper**: 新聞の共有設定更新
- **exportToPdf**: 新聞をPDFに変換

#### グループ関連
- **createGroup**: 研究グループ作成
- **updateGroup**: グループ情報更新
- **addGroupMember**: グループにメンバー追加
- **removeGroupMember**: グループからメンバー削除
- **listUserGroups**: ユーザーの所属グループ一覧

#### 決済関連
- **createCheckoutSession**: Stripe決済セッション作成
- **handleSubscriptionUpdate**: サブスクリプション状態更新処理
- **cancelSubscription**: サブスクリプション解約処理

### 4.2 Vertex AI実装詳細

#### 論文解析プロンプト設計
Vertex AI Gemini 2.0 Flashに対して適切な指示を与えるためのプロンプト設計：

1. **論文構造理解プロンプト**
```
あなたは学術論文専門のAIアシスタントです。以下のPDFから抽出されたテキストを解析し、論文の構造を特定してください。

[抽出テキスト]

以下の情報を特定して、JSON形式で出力してください:
1. 論文タイトル
2. 著者リスト
3. 所属機関
4. アブストラクト
5. キーワード
6. 章・セクション構造（階層的に）
7. 図表の参照箇所とキャプション
8. 結論
9. 参考文献
```

2. **要約生成プロンプト**
```
以下の学術論文を要約してください。専門家ではない読者にも理解できる平易な言葉で、研究の重要性と主要な発見を強調してください。

[論文テキスト]

以下の形式で回答してください:
1. 要約（200語以内）：研究の背景、目的、方法、結果、意義を含める
2. 重要ポイント（5項目）：箇条書きで研究の最も重要な側面を説明
3. 研究の意義（100語以内）：この研究が分野や社会にどのような影響を与えるか
4. 関連トピック（5つ）：この研究に関連する他の研究分野やトピック
```

3. **新聞スタイル変換プロンプト**
```
あなたは科学ジャーナリストです。以下の学術論文の内容を、一般の新聞読者向けの記事に変換してください。

論文タイトル: [タイトル]
著者: [著者リスト]
要約: [要約]

以下の新聞記事形式で執筆してください:
1. 見出し：インパクトがあり、研究の本質を捉えた20字以内の見出し
2. リード文：研究の重要性を強調した導入部（50字程度）
3. 本文：研究内容を平易に説明し、専門用語を避けた説明（400字程度）
4. 図表説明：主要な図表の内容を簡潔に説明（必要な場合のみ）
5. まとめ：研究の意義や今後の展望（50字程度）

新聞記事として、読者の興味を引き、最後まで読ませる構成にしてください。
```

#### AIモデル選定と利用方針

1. **メインAI処理**: Vertex AI Gemini 2.0 Flash
   - トークン制限: 1リクエストあたり32,000トークン
   - レスポンス速度: 低レイテンシ（平均1-3秒）
   - 使用用途:
     - 論文構造解析
     - 要約生成
     - 新聞記事スタイル変換
     - 関連性分析
   - 設定パラメータ:
     - temperature: 0.2（事実に基づく正確な出力）
     - topK: 40
     - topP: 0.8

2. **長文解析**: チャンク分割アプローチ
   - 論文をセクション単位でチャンク分割（最大8,000トークン）
   - チャンクごとに解析し、結果を統合
   - 重複情報の除去とマージアルゴリズム

3. **図表処理**: Vertex AI OCR + Vision API
   - 図表領域の検出と抽出
   - 図表内のテキスト認識
   - キャプションと図表の関連付け

4. **図表処理**:
   - 論文PDFからの図表抽出処理
   - 抽出できない図表は使用しない方針
   - 元論文の図表を改変せず正確に表示

### 4.3 エラーハンドリング戦略

1. **階層的エラー処理**
   - アプリケーション層エラー: ユーザー入力、権限関連
   - サービス層エラー: API連携、データ処理
   - インフラ層エラー: 接続、リソース制限

2. **リトライメカニズム**
   - 自動リトライ（Firebase Tasks Queue機能）
     - 指数バックオフ戦略
     - 最大リトライ回数: 5回
   - 永続化されたリクエスト処理

3. **エラーログとモニタリング**
   - 構造化ログ形式
   ```json
   {
     "severity": "ERROR",
     "timestamp": "2025-05-01T12:34:56Z",
     "service": "paper-analyzer",
     "paperId": "abc123",
     "error": {
       "code": "PROCESSING_ERROR",
       "message": "PDF解析中にエラーが発生しました",
       "details": { ... }
     },
     "context": { ... }
   }
   ```
   - リアルタイムアラート（Critical エラー）
   - 定期エラーレポート（日次/週次）

4. **グレースフルデグラデーション**
   - AI処理失敗時のフォールバックメカニズム
     - 部分的結果の利用
     - シンプルな代替処理の提供
   - ユーザーへの透明な通知

## 5. UI/UX詳細設計

### 5.1 Reactアーキテクチャ設計
- **コンポーネント設計アプローチ**: Atomic Design手法
  - **Atoms**: ボタン、入力フィールド、アイコン等の基本要素
  - **Molecules**: フォームグループ、カード、ナビゲーション項目等
  - **Organisms**: ヘッダー、フッター、サイドバー、フォーム等
  - **Templates**: ページレイアウトの枠組み
  - **Pages**: 実際のページコンポーネント

- **コンポーネント構造例**:
```
src/
├── components/
│   ├── atoms/
│   │   ├── Button/
│   │   ├── Input/
│   │   └── Typography/
│   ├── molecules/
│   │   ├── FormField/
│   │   ├── NewspaperCard/
│   │   └── PaperItem/
│   ├── organisms/
│   │   ├── Header/
│   │   ├── NewspaperEditor/
│   │   └── PaperUploader/
│   └── templates/
│       ├── DashboardTemplate/
│       ├── EditorTemplate/
│       └── AuthTemplate/
├── pages/
│   ├── Dashboard/
│   ├── NewspaperEditor/
│   ├── PaperManager/
│   └── ...
└── ...
```

- **状態管理設計**:
  - **Redux Toolkit**: グローバル状態管理
    - ユーザー情報
    - 新聞編集状態
    - 論文データ
  - **React Context**: 特定機能におけるローカル状態
    - テーマコンテキスト
    - 認証コンテキスト
    - モーダルコンテキスト
  - **ローカルステート**: コンポーネント内限定の状態

- **レンダリング最適化**:
  - `React.memo`による不要な再レンダリング防止
  - `useCallback`/`useMemo`によるパフォーマンス最適化
  - 仮想スクロール（大量リスト表示時）

### 5.2 パフォーマンス最適化
- **コード分割とLazy Loading**:
  ```jsx
  // 大きなコンポーネントの遅延ロード
  const NewspaperEditor = React.lazy(() => import('./components/organisms/NewspaperEditor'));
  
  // 使用例
  function App() {
    return (
      <Suspense fallback={<LoadingSpinner />}>
        <NewspaperEditor />
      </Suspense>
    );
  }
  ```

- **画像最適化**:
  - WebP形式の使用
  - サムネイル生成（プログレッシブロード）
  - 解像度に応じた画像提供

- **ローカルキャッシュ戦略**:
  - Redux Persistによる状態永続化
  - IndexedDBを使用した大きなデータの保存

### 5.3 新聞エディタのカスタムUI実装
- **縦書きテキストエディタ**:
  ```jsx
  const VerticalTextEditor = ({ value, onChange }) => {
    return (
      <div 
        className="vertical-text-container"
        style={{
          writingMode: 'vertical-rl',
          textOrientation: 'upright',
          height: '100%',
          overflowX: 'auto'
        }}
      >
        <ContentEditable
          html={value}
          onChange={onChange}
          tagName="article"
          className="vertical-text-editor"
        />
      </div>
    );
  };
  ```

- **ドラッグ&ドロップレイアウト**:
  ```jsx
  const NewspaperLayoutEditor = () => {
    // ドラッグ状態管理
    const [layout, setLayout] = useState(initialLayout);
    
    const handleDragEnd = (result) => {
      // ドラッグ処理完了後のレイアウト更新ロジック
      if (!result.destination) return;
      
      const items = Array.from(layout);
      const [reorderedItem] = items.splice(result.source.index, 1);
      items.splice(result.destination.index, 0, reorderedItem);
      
      setLayout(items);
    };
    
    return (
      <DragDropContext onDragEnd={handleDragEnd}>
        <NewspaperGrid layout={layout}>
          {layout.map((item) => (
            <Draggable key={item.id} draggableId={item.id} index={item.index}>
              {(provided) => (
                <NewspaperElement
                  ref={provided.innerRef}
                  {...provided.draggableProps}
                  {...provided.dragHandleProps}
                  item={item}
                />
              )}
            </Draggable>
          ))}
        </NewspaperGrid>
      </DragDropContext>
    );
  };
  ```

- **リアルタイムプレビュー**:
  ```jsx
  const NewspaperPreview = ({ content, template }) => {
    const [previewHtml, setPreviewHtml] = useState('');
    
    useEffect(() => {
      // コンテンツとテンプレートからHTMLを生成
      const generatePreview = async () => {
        try {
          const htmlTemplate = getTemplateHtml(template);
          const filledHtml = applyContentToTemplate(htmlTemplate, content);
          setPreviewHtml(filledHtml);
        } catch (error) {
          console.error('プレビュー生成エラー:', error);
        }
      };
      
      generatePreview();
    }, [content, template]);
    
    return (
      <div className="preview-container">
        <iframe
          title="新聞プレビュー"
          srcDoc={previewHtml}
          className="newspaper-preview"
          sandbox="allow-same-origin"
        />
      </div>
    );
  };
  ```

## 6. 新聞レイアウト詳細

### 6.1 基本レイアウト構造
実際の新聞（日本教育新聞など）と同様のレイアウト構造を採用します。特に日本の新聞の特徴である縦書きレイアウトと複数カラム構成、階層的な見出し構造を忠実に再現します。

```
┌─────────────────────────────────────────────────────────────────────────┐
│ ┌───────┐ ┌─────────────────────────────┐ ┌───────────────┐ ┌─────────┐│
│ │号数   │ │      新聞名・日付・曜日     │ │     題字     │ │ヘッダー右││
│ └───────┘ └─────────────────────────────┘ └───────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────┐ ┌─────────┐ ┌─────────────┐│
│ │                                         │ │見出し小 │ │             ││
│ │          主見出し（太ゴシック体）        │ ├─────────┤ │             ││
│ │                                         │ │         │ │             ││
│ ├─────────────────────────────────────────┤ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │   人物  │ │   右カラム  ││
│ │    │    │    │    │    │    │    │     │ │   写真  │ │    記事    ││
│ │    │    │    │    │    │    │    │     │ │         │ │  （縦書き） ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ メ │ イ │ ン │ 記 │ 事 │ 本 │ 文 │     │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ （ │ 縦 │ 書 │ き │ ・ │ 複 │ 数 │ カ   │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ ラ │ ム │ ） │    │    │    │    │     │ ├─────────┤ │             ││
│ │    │    │    │    │    │    │    │     │ │ 小見出し │ │             ││
│ │    │    │    │    │    │    │    │     │ │（網掛け）│ │             ││
│ └─────────────────────────────────────────┘ └─────────┘ └─────────────┘│
├─────────────────────────────────────────────┬─────────────────────────┤
│ ┌─────────────────────────────────────────┐ │ ┌─────────┐ ┌─────────┐ │
│ │             │                           │ │ │         │ │         │ │
│ │  中見出し   │    下部記事（縦書き）      │ │ │ QRコード │ │  広告枠  │ │
│ │             │                           │ │ │         │ │         │ │
│ └─────────────────────────────────────────┘ │ └─────────┘ └─────────┘ │
├─────────────────────────────────────────────┼─────────────────────────┤
│ ┌─────────────────────────┐ ┌─────────────┐ │ ┌───────────────────────┐│
│ │                         │ │             │ │ │                       ││
│ │     左下部記事          │ │  図表/写真  │ │ │      右下部記事       ││
│ │    （縦書き）           │ │             │ │ │     （縦書き）        ││
│ └─────────────────────────┘ └─────────────┘ │ └───────────────────────┘│
└─────────────────────────────────────────────┴─────────────────────────┘
```

### 6.2 レイアウト実装技術
- CSS Grid + Flexboxによる複雑な新聞レイアウト実現
  ```css
  .newspaper-container {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: auto auto auto auto;
    gap: 2px;
    background-color: #fafafa;
    padding: 10px;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
  }
  
  .newspaper-header {
    grid-column: 1 / span 6;
    grid-row: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #000;
    padding-bottom: 5px;
  }
  
  .main-headline {
    grid-column: 1 / span 4;
    grid-row: 2;
    border-bottom: 1px solid #000;
    padding: 10px 0;
  }
  
  .main-article {
    grid-column: 1 / span 4;
    grid-row: 3;
    writing-mode: vertical-rl;
    padding: 5px;
    overflow-x: auto;
    height: 500px;
  }
  
  .sidebar {
    grid-column: 5 / span 2;
    grid-row: 2 / span 2;
    writing-mode: vertical-rl;
    border-left: 1px solid #000;
    padding: 5px;
  }
  ```

- 縦書きテキスト: `writing-mode: vertical-rl`
  ```css
  .vertical-text {
    writing-mode: vertical-rl;
    text-orientation: upright;
    font-family: "游明朝", "Yu Mincho", YuMincho, serif;
    line-height: 1.8;
    letter-spacing: 0.05em;
    height: 100%;
    overflow-x: auto;
  }
  
  /* 英数字を横向きに */
  .vertical-text span.latin {
    text-orientation: mixed;
  }
  
  /* 縦中横（数字などを横書きに） */
  .tcy {
    text-combine-upright: all;
    text-orientation: upright;
  }
  ```

- 新聞特有の組版ルール適用
  ```css
  /* 行頭禁則 */
  .vertical-text {
    word-break: normal;
    overflow-wrap: break-word;
    line-break: strict;
  }
  
  /* ぶら下げ組版 */
  .hanging-punctuation {
    hanging-punctuation: force-end;
  }
  
  /* 圏点（傍点） */
  .emphasis {
    text-emphasis: filled sesame;
    text-emphasis-position: over right;
  }
  ```

### 6.3 テンプレートバリエーション実装
各テンプレートは、JSON形式で定義され、フロントエンドで動的にレンダリングされます：

```javascript
// テンプレート定義例
const classicTemplate = {
  id: "classic",
  name: "クラシック",
  description: "伝統的な活字新聞風デザイン",
  isPremium: false,
  layout: {
    version: "1.0",
    components: [
      {
        type: "header",
        id: "newspaper-header",
        position: { x: 0, y: 0 },
        size: { width: 100, height: 10 },
        styles: {
          borderBottom: "2px solid #000",
          fontFamily: "'游明朝', YuMincho, serif"
        }
      },
      {
        type: "headline",
        id: "main-headline",
        position: { x: 0, y: 10 },
        size: { width: 70, height: 10 },
        styles: {
          fontSize: "28px",
          fontWeight: "bold",
          borderBottom: "1px solid #000"
        }
      },
      {
        type: "textContent",
        id: "main-article",
        position: { x: 0, y: 20 },
        size: { width: 70, height: 50 },
        styles: {
          writingMode: "vertical-rl",
          fontFamily: "'游明朝', YuMincho, serif",
          fontSize: "16px",
          lineHeight: 1.8,
          height: "500px"
        }
      },
      // 他のコンポーネント定義...
    ]
  }
};

// テンプレートマッピング
const templateRegistry = {
  "standard": standardTemplate,
  "classic": classicTemplate,
  "modern": modernTemplate,
  // プレミアムテンプレート
  "academic": academicTemplate,
  "technical": technicalTemplate,
  // 他のテンプレート...
};

// テンプレート選択ロジック
function getTemplate(templateId, isPremiumUser) {
  const template = templateRegistry[templateId];
  
  if (!template) {
    return templateRegistry["standard"]; // デフォルト
  }
  
  if (template.isPremium && !isPremiumUser) {
    throw new Error("このテンプレートは有料会員専用です");
  }
  
  return template;
}
```

## 7. テスト計画詳細

### 7.1 単体テスト戦略
- **フロントエンドテスト**:
  ```javascript
  // Reactコンポーネントテスト例
  import { render, screen, fireEvent } from '@testing-library/react';
  import PaperUploader from './PaperUploader';
  
  describe('PaperUploader', () => {
    test('初期状態では空のドロップエリアを表示', () => {
      render(<PaperUploader onUpload={jest.fn()} />);
      
      expect(screen.getByText('PDFをドロップ')).toBeInTheDocument();
      expect(screen.queryByText('アップロード中')).not.toBeInTheDocument();
    });
    
    test('ファイル選択後、アップロードボタンが有効になる', () => {
      render(<PaperUploader onUpload={jest.fn()} />);
      
      const file = new File(['dummy content'], 'sample.pdf', { type: 'application/pdf' });
      const fileInput = screen.getByLabelText('ファイルを選択');
      
      Object.defineProperty(fileInput, 'files', {
        value: [file]
      });
      
      fireEvent.change(fileInput);
      
      expect(screen.getByText('アップロード')).toBeEnabled();
    });
  });
  ```

- **バックエンドテスト**:
  ```javascript
  // Firebase Functions テスト例
  const test = require('firebase-functions-test')();
  const admin = require('firebase-admin');
  const functions = require('../index');

  describe('uploadPaper', () => {
    beforeEach(() => {
      // Firestoreモック
      jest.spyOn(admin.firestore(), 'collection').mockImplementation(() => ({
        doc: jest.fn().mockReturnValue({
          id: 'test-paper-id',
          set: jest.fn().mockResolvedValue(true)
        })
      }));
      
      // Storageモック
      jest.spyOn(admin.storage(), 'bucket').mockImplementation(() => ({
        file: jest.fn().mockReturnValue({
          save: jest.fn().mockResolvedValue([]),
          getSignedUrl: jest.fn().mockResolvedValue(['https://test-url.com/file.pdf'])
        })
      }));
    });
    
    test('有効なPDFを処理して保存する', async () => {
      const wrapped = test.wrap(functions.uploadPaper);
      
      const data = {
        fileBase64: 'data:application/pdf;base64,dGVzdA==', // "test" in base64
        fileName: 'test.pdf',
        fileSize: 1024
      };
      
      const context = {
        auth: { uid: 'test-user' }
      };
      
      const result = await wrapped(data, context);
      
      expect(result.success).toBe(true);
      expect(result.paperId).toBe('test-paper-id');
      expect(admin.firestore().collection).toHaveBeenCalledWith('papers');
    });
  });
  ```

### 7.2 統合テスト戦略
- **エンドツーエンドテスト**:
  ```javascript
  // Cypressテスト例
  describe('新聞生成フロー', () => {
    beforeEach(() => {
      cy.login('test@example.com', 'password123');
    });
    
    it('論文をアップロードして新聞を生成できる', () => {
      // ダッシュボードに移動
      cy.visit('/dashboard');
      
      // 論文管理ページに移動
      cy.findByText('論文を管理').click();
      
      // 論文アップロード
      cy.findByText('論文をアップロード').click();
      cy.get('input[type=file]').attachFile('test-paper.pdf');
      cy.findByText('アップロード').click();
      
      // アップロード完了を確認
      cy.findByText('アップロード完了').should('be.visible');
      
      // 論文選択
      cy.get('[data-testid=paper-checkbox]').first().check();
      
      // 新聞生成開始
      cy.findByText('新聞を作成').click();
      
      // テンプレート選択
      cy.findByText('スタンダード').click();
      cy.findByText('次へ').click();
      
      // 生成中画面が表示され、その後エディタが表示されることを確認
      cy.findByText('新聞を生成中').should('be.visible');
      cy.findByText('新聞エディタ', { timeout: 60000 }).should('be.visible');
      
      // 生成された新聞の内容確認
      cy.get('.newspaper-container').should('exist');
      cy.get('.main-headline').should('not.be.empty');
    });
  });
  ```

### 7.3 ロード・パフォーマンステスト
- **負荷テスト設定**:
  ```javascript
  // k6負荷テスト例
  import http from 'k6/http';
  import { sleep, check } from 'k6';
  
  export const options = {
    stages: [
      { duration: '1m', target: 10 }, // 10ユーザーまでランプアップ
      { duration: '3m', target: 10 }, // 10ユーザーで3分間維持
      { duration: '1m', target: 50 }, // 50ユーザーまでランプアップ
      { duration: '3m', target: 50 }, // 50ユーザーで3分間維持
      { duration: '1m', target: 0 },  // ランプダウン
    ],
    thresholds: {
      http_req_duration: ['p(95)<3000'], // 95%のリクエストが3秒以内に完了すること
      http_req_failed: ['rate<0.01'],    // 失敗率1%未満
    },
  };
  
  export default function () {
    // ログイン処理
    const loginRes = http.post('https://api.example.com/login', {
      email: 'loadtest@example.com',
      password: 'password123',
    });
    
    check(loginRes, {
      'ログイン成功': (r) => r.status === 200,
    });
    
    const authToken = loginRes.json('token');
    
    // 論文一覧取得
    const papersRes = http.get('https://api.example.com/papers', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
    });
    
    check(papersRes, {
      '論文一覧取得成功': (r) => r.status === 200,
    });
    
    sleep(2);
    
    // 新聞一覧取得
    const newspapersRes = http.get('https://api.example.com/newspapers', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
    });
    
    check(newspapersRes, {
      '新聞一覧取得成功': (r) => r.status === 200,
    });
    
    sleep(3);
  }
  ```

## 8. デプロイメント・運用戦略

### 8.1 CI/CD詳細設計
GitHub Actionsを使用したCI/CDパイプライン：

```yaml
# .github/workflows/deploy.yml
name: Deploy Application

on:
  push:
    branches: [ main, staging ]
  pull_request:
    branches: [ main, staging ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      # 環境変数設定
      - name: Set environment variables
        run: |
          if [[ $GITHUB_REF == refs/heads/main ]]; then
            echo "FIREBASE_PROJECT=production" >> $GITHUB_ENV
          else
            echo "FIREBASE_PROJECT=staging" >> $GITHUB_ENV
          fi
      
      # 依存関係インストール
      - run: npm ci
      
      # ビルド
      - run: npm run build
      
      # Firebase デプロイ
      - name: Deploy to Firebase
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          channelId: live
          projectId: '${{ env.FIREBASE_PROJECT }}'
        env:
          FIREBASE_CLI_PREVIEWS: hostingchannels
```

### 8.2 環境分離戦略
- **開発環境**:
  - Firebase Project: `research-news-dev`
  - 特徴:
    - 開発者のローカル環境に接続
    - Firestore エミュレータ使用可能
    - AI処理のモックオプション

- **ステージング環境**:
  - Firebase Project: `research-news-staging`
  - 特徴:
    - CI/CDパイプラインで自動デプロイ
    - 本番環境と同一構成
    - テストユーザーデータ

- **本番環境**:
  - Firebase Project: `research-news-prod`
  - 特徴:
    - 手動承認後デプロイ
    - バックアップ体制
    - スケーリング監視

### 8.3 モニタリング・アラート設定
- **Google Cloud Monitoringダッシュボード**:
  - リアルタイムユーザー数
  - エラー率
  - レスポンスタイム
  - リソース使用率

- **アラート設定**:
  ```yaml
  # アラートポリシー例
  policies:
    - displayName: "高エラー率検知"
      conditions:
        - displayName: "エラー率5%超過"
          condition:
            filter: "resource.type = cloud_function AND log_name = projects/research-news-prod/logs/cloudfunctions.googleapis.com%2Fcloud-functions"
            metricThreshold:
              metric: "logging.googleapis.com/log_entry_count"
              filter: "severity>=ERROR"
              aggregations:
                - alignmentPeriod: 300s
                  perSeriesAligner: ALIGN_RATE
              comparison: COMPARISON_GT
              thresholdValue: 0.05
      alertStrategy:
        notificationRateLimitPeriod: 3600s
        autoClose: 86400s
      notificationChannels:
        - "projects/research-news-prod/notificationChannels/slack-alerts"
        - "projects/research-news-prod/notificationChannels/email-dev-team"
  ```

### 8.4 バックアップ・災害復旧計画
- **バックアップスケジュール**:
  - Firestoreデータ: 日次完全バックアップ
  - Storageデータ: 週次増分バックアップ
  - 保持期間: 30日間

- **復旧時間目標 (RTO)**:
  - 重大障害時: 4時間以内
  - 軽微障害時: 2時間以内

- **復旧ポイント目標 (RPO)**:
  - データ損失許容範囲: 24時間以内

- **災害復旧テスト**:
  - 四半期ごとにリハーサル実施
  - フェイルオーバー手順の文書化と訓練

## 9. セキュリティ実装

### 9.1 認証・認可の詳細実装
- **Firebase Authentication**:
  ```javascript
  // 認証ミドルウェア実装例
  const checkAuth = async (req, res, next) => {
    try {
      const idToken = req.headers.authorization?.split('Bearer ')[1];
      
      if (!idToken) {
        return res.status(401).json({ error: '認証が必要です' });
      }
      
      const decodedToken = await admin.auth().verifyIdToken(idToken);
      req.user = decodedToken;
      
      // ユーザーデータ取得
      const userDoc = await admin.firestore().collection('users').doc(decodedToken.uid).get();
      req.userData = userDoc.data();
      
      return next();
    } catch (error) {
      console.error('認証エラー:', error);
      return res.status(401).json({ error: '認証に失敗しました' });
    }
  };
  ```

- **Firestore セキュリティルール**:
  ```
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      // ユーザーデータ
      match /users/{userId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if false; // 削除禁止
      }
      
      // 新聞データ
      match /newspapers/{newspaperId} {
        allow read: if isOwner() || isSharedWithUser() || resource.data.isPublic == true;
        allow create: if isAuthenticated() && validateNewspaper();
        allow update: if isOwner() && validateNewspaper();
        allow delete: if isOwner();
        
        function isOwner() {
          return request.auth != null && resource.data.creatorId == request.auth.uid;
        }
        
        function isSharedWithUser() {
          return request.auth != null && 
                 (resource.data.shareSettings.type == 'group' && 
                  resource.data.shareSettings.groupIds.hasAny(getUserGroups()));
        }
        
        function getUserGroups() {
          return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.groups || [];
        }
        
        function validateNewspaper() {
          return request.resource.data.creatorId == request.auth.uid;
        }
      }
      
      // 論文データ
      match /papers/{paperId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated();
        allow update: if isAuthenticated() && isPaperOwner();
        allow delete: if isPaperOwner();
        
        function isPaperOwner() {
          return request.auth.uid == resource.data.uploaderId;
        }
      }
      
      // グループデータ
      match /groups/{groupId} {
        allow read: if isGroupMember();
        allow create: if isAuthenticated();
        allow update: if isGroupAdmin();
        allow delete: if isGroupAdmin();
        
        function isGroupMember() {
          return request.auth != null && 
                exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
        }
        
        function isGroupAdmin() {
          return request.auth != null && 
                get(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin';
        }
      }
      
      // 共通関数
      function isAuthenticated() {
        return request.auth != null;
      }
    }
  }
  ```

### 9.2 データ保護実装
- **機密データの暗号化**:
  ```javascript
  // ユーティリティ関数例
  const crypto = require('crypto');
  
  // 環境変数から暗号化キーを取得
  const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
  const IV_LENGTH = 16; // AES ブロックサイズ
  
  // データ暗号化関数
  function encrypt(text) {
    const iv = crypto.randomBytes(IV_LENGTH);
    const cipher = crypto.createCipheriv(
      'aes-256-cbc', 
      Buffer.from(ENCRYPTION_KEY, 'hex'), 
      iv
    );
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return `${iv.toString('hex')}:${encrypted}`;
  }
  
  // データ復号化関数
  function decrypt(text) {
    const textParts = text.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedText = textParts.join(':');
    const decipher = crypto.createDecipheriv(
      'aes-256-cbc',
      Buffer.from(ENCRYPTION_KEY, 'hex'),
      iv
    );
    
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  ```

- **Firebase Storage セキュリティルール**:
  ```
  rules_version = '2';
  service firebase.storage {
    match /b/{bucket}/o {
      // 論文ファイル
      match /papers/{userId}/{paperId}.pdf {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      
      // 新聞関連ファイル
      match /newspapers/{newspaperId}/{fileName} {
        allow read: if isOwnerOrShared(newspaperId);
        allow write: if isOwner(newspaperId);
      }
      
      // ユーザーカスタムロゴ
      match /logos/{userId}/{fileName} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId && isPremiumUser();
      }
      
      // ヘルパー関数
      function isOwner(newspaperId) {
        return request.auth != null && 
               firestore.get(/databases/(default)/documents/newspapers/$(newspaperId)).data.creatorId == request.auth.uid;
      }
      
      function isOwnerOrShared(newspaperId) {
        let newspaper = firestore.get(/databases/(default)/documents/newspapers/$(newspaperId)).data;
        return request.auth != null && (
          newspaper.creatorId == request.auth.uid ||
          newspaper.isPublic == true ||
          (newspaper.shareSettings.type == 'group' && hasGroupAccess(newspaper.shareSettings.groupIds))
        );
      }
      
      function hasGroupAccess(groupIds) {
        return request.auth != null && request.auth.token.groups.hasAny(groupIds);
      }
      
      function isPremiumUser() {
        return request.auth != null && 
               firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.membershipTier == 'premium';
      }
    }
  }
  ```