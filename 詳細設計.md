# 論文ベース新聞一面生成システム 詳細設計書（改訂版）

## 1. システム概要
本システムは学術論文をAIで解析し、新聞一面形式に自動変換するWebアプリケーションです。研究者間の情報共有や一般の方々への研究成果の可視化を目的としています。

### 1.1 システムアーキテクチャ
- **クライアント-サーバー型アーキテクチャ**
  - フロントエンド: Next.js 14/TypeScript（App Router）
  - バックエンド: Firebase (Firestore, Functions, Authentication)
  - AI処理: Vertex AI Gemini 2.0 Flash
  - PDF処理: React-PDF, PDFKit
  - 決済処理: Stripe API
  - SSR/SSG: Next.js App Router

### 1.2 プロジェクト構造
```
/
├── app/                      # Next.js App Router
│   ├── (auth)/              # 認証関連ページ
│   │   ├── login/          # ログインページ
│   │   └── register/       # 登録ページ
│   ├── (dashboard)/        # ダッシュボード関連
│   │   ├── papers/        # 論文管理
│   │   └── newspapers/    # 新聞管理
│   ├── api/               # APIルート
│   └── layout.tsx         # ルートレイアウト
├── components/            # 共通コンポーネント
│   ├── ui/              # UIコンポーネント
│   └── features/        # 機能コンポーネント
├── lib/                  # 共通ライブラリ
│   ├── firebase/        # Firebase設定
│   └── utils/           # ユーティリティ
├── public/              # 静的ファイル
└── package.json
│
└── functions/                # バックエンド（Cloud Functions）
    ├── src/
    │   ├── api/             # API実装
    │   │   ├── auth/        # 認証関連
    │   │   ├── papers/      # 論文関連
    │   │   └── newspapers/  # 新聞関連
    │   ├── ai/              # AI処理関連
    │   │   ├── services/    # AIサービス実装
    │   │   ├── prompts/     # プロンプトテンプレート
    │   │   └── utils/       # AI関連ユーティリティ
    │   └── utils/           # 共通ユーティリティ
    └── package.json
```

### 1.2 全体構成図
```
┌─────────────┐     ┌───────────────┐     ┌─────────────────┐
│             │     │               │     │                 │
│ クライアント  │◄────►│ Firebase     │◄────►│ Vertex AI       │
│ (React SPA) │     │ (BaaS)       │     │ Gemini 2.0 Flash  │
│             │     │               │     │                 │
└─────────────┘     └───────────────┘     └─────────────────┘
                          ▲
                          │
                          ▼
                    ┌──────────────┐
                    │              │
                    │ Stripe API   │
                    │ (決済処理)    │
                    │              │
                    └──────────────┘
```

## 2. 技術スタック詳細

### 2.1 フロントエンド
- **フレームワーク**: Next.js 14.x
- **言語**: TypeScript 5.x
- **状態管理**: React Context + Server Components
- **ルーティング**: Next.js App Router
- **UI/スタイリング**:
  - Material UI v5.x
  - Tailwind CSS
  - Material Icons
- **フォーム管理**: React Hook Form + Zod (バリデーション)
- **PDF生成/操作**: React-PDF, PDFKit
- **グラフ/可視化**: D3.js
- **HTTP通信**: Next.js API Routes
- **テスト**: Jest, React Testing Library, Playwright
- **ビルドツール**: Next.js (内蔵ビルドツール)
- **コンポーネント設計**: Server/Client Components + Atomic Design手法

### 2.2 バックエンド
- **プラットフォーム**: Firebase
  - **データベース**: Firestore
  - **ストレージ**: Firebase Storage
  - **認証**: Firebase Authentication
  - **サーバーレス関数**: Firebase Functions (Node.js 18.x)
  - **ホスティング**: Firebase Hosting
- **API通信**:
  - RESTful API設計
  - JSON形式でのデータ交換
- **バッチ処理**: Cloud Scheduler + Cloud Functions
- **キャッシュ戦略**: Firebase Cache Control

### 2.3 AI/ML
- **論文解析**: Vertex AI Gemini 2.0 Flash
  - テキスト解析・要約
  - 関連性分析
  - 見出し・記事生成
  - **プロンプト設計**:
    - 体系的なプロンプトテンプレート
    - 論文構造認識プロンプト
    - 新聞スタイル変換プロンプト
  - **コンテキスト管理**:
    - トークン最適化
    - 重要情報抽出戦略
- **画像処理**:
  - OCR処理 (論文PDFからのテキスト抽出)
  - 論文からの図表抽出処理
  - テーブル変換・正規化処理

### 2.4 インフラ
- **クラウド**: Google Cloud Platform
  - **計算リソース**: 標準Compute Engineインスタンス (e2-standard-4)
  - **スケーリング**: 自動スケーリングルール設定
  - **リージョン設定**: asia-northeast1 (東京)
- **CI/CD**: GitHub Actions
  - **テスト・デプロイパイプライン**
  - **環境分離**: 開発/ステージング/本番
- **監視/ロギング**: Firebase Analytics, Google Cloud Monitoring
  - **アラート設定**: エラー率、レスポンスタイム閾値
  - **ログ集約**: Cloud Logging
- **バックアップ**: 自動日次バックアップ (GCS)
  - **リテンション期間**: 30日間
  - **復旧テスト**: 月次実施

## 3. データベース設計

### 3.1 Firestoreコレクション設計

#### users
```
{
  uid: string (PK),  // Firebase Authenticationから生成されるID
  email: string,
  displayName: string,
  profileImageUrl: string,
  membershipTier: string,  // "free" | "premium"
  membershipStartDate: timestamp,
  membershipEndDate: timestamp,
  paymentId: string,  // Stripe顧客ID
  generatedCount: number,  // 生成回数カウント（無料会員用）
  savedNewspapersCount: number,  // 保存した新聞数（無料会員用）
  createdAt: timestamp,
  updatedAt: timestamp,
  lastLoginAt: timestamp,
  preferredLanguage: string,  // "ja" | "en" | "zh" (多言語対応用)
  settings: {
    notifications: boolean,
    theme: string  // "light" | "dark" | "system"
  }
}
```

#### newspapers
```
{
  id: string (PK),
  creatorId: string (FK -> users.uid),
  title: string,
  templateId: string,
  isPublic: boolean,
  shareSettings: {
    type: string,  // "private" | "group" | "public"
    groupIds: string[],  // 共有するグループIDリスト
    viewCount: number,  // 閲覧数カウント
    shareUrl: string  // 共有用一意URL
  },
  content: {
    header: {
      newspaperName: string,
      date: string,
      issueNumber: string
    },
    mainArticle: {
      headline: string,
      subheadline: string,
      content: string,
      imageUrl: string,
      paperIds: string[]  // 関連論文ID
    },
    subArticles: [
      {
        headline: string,
        content: string,
        imageUrl: string,
        paperId: string
      }
    ],
    sidebarContent: string,
    columnContent: string,
    adContent: string,  // 無料会員用広告
    footer: string
  },
  customSettings: {
    fontFamily: string,
    colorScheme: string,
    logoUrl: string
  },
  exportHistory: [
    {
      type: string,  // "pdf" | "png" | "print"
      url: string,  // 生成ファイルへのパス
      createdAt: timestamp
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### papers
```
{
  id: string (PK),
  uploaderId: string (FK -> users.uid),
  title: string,
  authors: string[],
  journal: string,
  publicationDate: string,
  doi: string,
  fileUrl: string,  // Storage内のPDFパス
  fileSize: number,
  metadata: {
    abstract: string,
    keywords: string[],
    figures: [
      {
        id: string,
        caption: string,
        imageUrl: string,
        page: number,
        importance: number  // AIによる重要度スコア (0-100)
      }
    ],
    tables: [
      {
        id: string,
        caption: string,
        data: string,  // JSON形式テーブルデータ
        page: number
      }
    ],
    citations: [
      {
        id: string,
        text: string,
        reference: string
      }
    ],
    extractedText: string,  // 抽出されたフルテキスト
  },
  aiAnalysis: {
    summary: string,
    keypoints: string[],
    significance: string,
    relatedTopics: string[],
    academicField: string,
    technicalLevel: string,  // "beginner" | "intermediate" | "advanced"
    aiConfidenceScore: number  // 解析精度の自己評価スコア (0-100)
  },
  processingStatus: string,  // "pending" | "processing" | "completed" | "failed"
  errorLogs: [
    {
      timestamp: timestamp,
      code: string,
      message: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### groups
```
{
  id: string (PK),
  name: string,
  description: string,
  creatorId: string (FK -> users.uid),
  members: [
    {
      userId: string,
      role: string,  // "admin" | "member" | "viewer"
      joinedAt: timestamp,
      lastActivity: timestamp
    }
  ],
  sharedNewspapers: string[],  // 新聞IDリスト
  invitationLinks: [
    {
      id: string,
      url: string,
      expiresAt: timestamp,
      usedCount: number,
      maxUses: number  // 招待制限数
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### templates
```
{
  id: string (PK),
  name: string,
  description: string,
  previewImageUrl: string,
  isPremium: boolean,
  category: string,  // "standard" | "academic" | "magazine" | "tabloid"
  layout: {
    // レイアウト定義（JSON形式）
    // 要素の位置、サイズ、スタイルなど
    version: string,
    components: [
      {
        type: string,
        id: string,
        position: { x: number, y: number },
        size: { width: number, height: number },
        styles: object,
        content: object
      }
    ]
  },
  compatibleLanguages: string[],  // 対応言語リスト
  usageCount: number,  // 使用回数（人気度）
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### payments
```
{
  id: string (PK),
  userId: string (FK -> users.uid),
  stripeCustomerId: string,
  stripeSubscriptionId: string,
  plan: string,  // "monthly" | "yearly"
  amount: number,
  currency: string,
  status: string,  // "active" | "canceled" | "past_due"
  startDate: timestamp,
  endDate: timestamp,
  paymentMethod: {
    type: string,  // "credit_card" | "bank_transfer"
    last4: string,
    brand: string,
    expiryDate: string
  },
  invoices: [
    {
      id: string,
      amount: number,
      status: string,
      paidAt: timestamp,
      receiptUrl: string
    }
  ],
  createdAt: timestamp,
  updatedAt: timestamp
}
```

#### systemSettings
```
{
  id: string (PK),
  aiSettings: {
    modelVersion: string,
    maxTokens: number,
    temperatureDefault: number,
    contextWindowSize: number
  },
  freeUserLimits: {
    generationCount: number,  // 月当たりの生成可能回数
    savedNewspaperCount: number,  // 保存可能な新聞数
    exportFormats: string[]  // 利用可能なエクスポート形式
  },
  premiumUserLimits: {
    maxStorageSize: number,  // GB単位
    maxFileSize: number  // MB単位
  },
  maintenanceMode: boolean,
  notificationMessages: [
    {
      id: string,
      message: string,
      severity: string,  // "info" | "warning" | "error"
      startDate: timestamp,
      endDate: timestamp
    }
  ],
  updatedAt: timestamp,
  updatedBy: string
}
```

### 3.2 Firebase Storage構造
```
/papers/{userId}/{paperId}.pdf  // アップロードされた論文PDF
/figures/{paperId}/{figureId}.{ext}  // 論文から抽出された図表
/tables/{paperId}/{tableId}.json  // 論文から抽出されたテーブルデータ
/newspapers/{newspaperId}/preview.png  // 新聞プレビュー画像
/newspapers/{newspaperId}/export.pdf  // エクスポートされたPDF
/newspapers/{newspaperId}/export.png  // エクスポートされたPNG
/logos/{userId}/custom_logo.{ext}  // カスタムロゴ（有料会員）
/templates/{templateId}/preview.png  // テンプレートプレビュー
/system/backups/daily/{date}/  // システムバックアップ
```

### 3.3 データベースインデックス設計
効率的なクエリ処理のために以下のインデックスを設定:

```
// 新聞検索用複合インデックス
- コレクション: newspapers
  フィールド: 
    - creatorId (ASC)
    - createdAt (DESC)

// 共有新聞検索
- コレクション: newspapers
  フィールド:
    - shareSettings.type (ASC)
    - createdAt (DESC)

// 論文検索
- コレクション: papers
  フィールド:
    - uploaderId (ASC)
    - createdAt (DESC)

// グループメンバーシップ
- コレクション: groups
  フィールド:
    - "members.userId" (ASC)
    - createdAt (DESC)
```

## 4. API設計

### 4.1 Firebase Functions API実装詳細

#### 認証関連
- **createUser**: 新規ユーザー登録
  ```typescript
  // 実装概要
  export const createUser = functions.https.onCall(async (data, context) => {
    // バリデーション
    const { email, password, displayName } = data;
    if (!email || !password || !displayName) {
      throw new functions.https.HttpsError('invalid-argument', '必須項目が不足しています');
    }
    
    try {
      // Firebaseユーザー作成
      const userRecord = await admin.auth().createUser({
        email,
        password,
        displayName
      });
      
      // Firestoreにユーザーデータ保存
      await admin.firestore().collection('users').doc(userRecord.uid).set({
        uid: userRecord.uid,
        email,
        displayName,
        membershipTier: 'free',
        generatedCount: 0,
        savedNewspapersCount: 0,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      return { success: true, uid: userRecord.uid };
    } catch (error) {
      console.error('ユーザー作成エラー:', error);
      throw new functions.https.HttpsError('internal', 'ユーザー登録に失敗しました');
    }
  });
  ```

- **updateUserProfile**: ユーザープロファイル更新
- **upgradeToPremi um**: 有料会員へのアップグレード処理
  ```typescript
  // 実装概要
  export const upgradeToPremium = functions.https.onCall(async (data, context) => {
    // 認証確認
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
    }
    
    const uid = context.auth.uid;
    const { paymentMethodId, planType } = data;
    
    try {
      // ユーザーデータ取得
      const userDoc = await admin.firestore().collection('users').doc(uid).get();
      const userData = userDoc.data();
      
      if (!userData) {
        throw new functions.https.HttpsError('not-found', 'ユーザーが見つかりません');
      }
      
      // Stripe顧客作成/取得
      let stripeCustomerId = userData.paymentId;
      if (!stripeCustomerId) {
        const customer = await stripe.customers.create({
          email: userData.email,
          name: userData.displayName,
          payment_method: paymentMethodId,
          invoice_settings: {
            default_payment_method: paymentMethodId
          }
        });
        stripeCustomerId = customer.id;
      }
      
      // サブスクリプション作成
      const priceId = planType === 'monthly' ? PRICE_ID_MONTHLY : PRICE_ID_YEARLY;
      const subscription = await stripe.subscriptions.create({
        customer: stripeCustomerId,
        items: [{ price: priceId }],
        expand: ['latest_invoice.payment_intent']
      });
      
      // ユーザーデータ更新
      const now = admin.firestore.Timestamp.now();
      const endDate = planType === 'monthly' 
        ? new Date(now.toDate().setMonth(now.toDate().getMonth() + 1))
        : new Date(now.toDate().setFullYear(now.toDate().getFullYear() + 1));
        
      await admin.firestore().collection('users').doc(uid).update({
        membershipTier: 'premium',
        paymentId: stripeCustomerId,
        membershipStartDate: now,
        membershipEndDate: admin.firestore.Timestamp.fromDate(endDate),
        updatedAt: now
      });
      
      // 支払い記録作成
      await admin.firestore().collection('payments').add({
        userId: uid,
        stripeCustomerId,
        stripeSubscriptionId: subscription.id,
        plan: planType,
        amount: planType === 'monthly' ? 800 : 8000,
        currency: 'jpy',
        status: 'active',
        startDate: now,
        endDate: admin.firestore.Timestamp.fromDate(endDate),
        createdAt: now,
        updatedAt: now
      });
      
      return { success: true, subscriptionId: subscription.id };
    } catch (error) {
      console.error('アップグレードエラー:', error);
      throw new functions.https.HttpsError('internal', '有料会員へのアップグレードに失敗しました');
    }
  });
  ```

#### 論文関連
- **uploadPaper**: 論文PDFアップロード・保存
  ```typescript
  // 実装概要
  export const uploadPaper = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '2GB'
    })
    .https.onCall(async (data, context) => {
      // 認証確認
      if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
      }
      
      const uid = context.auth.uid;
      const { fileBase64, fileName, fileSize } = data;
      
      // ファイルサイズチェック
      if (fileSize > 20 * 1024 * 1024) { // 20MB制限
        throw new functions.https.HttpsError(
          'invalid-argument', 
          'ファイルサイズは20MB以下にしてください'
        );
      }
      
      try {
        // Base64デコード
        const fileBuffer = Buffer.from(fileBase64.split(',')[1], 'base64');
        
        // PDFバリデーション (MIMEタイプ確認など)
        const fileMime = await fileType.fromBuffer(fileBuffer);
        if (fileMime?.mime !== 'application/pdf') {
          throw new functions.https.HttpsError(
            'invalid-argument', 
            'アップロードできるのはPDFファイルのみです'
          );
        }
        
        // 一意のファイル名生成
        const paperId = admin.firestore().collection('papers').doc().id;
        const storagePath = `papers/${uid}/${paperId}.pdf`;
        
        // Firebase Storageにアップロード
        const bucket = admin.storage().bucket();
        const file = bucket.file(storagePath);
        await file.save(fileBuffer, {
          contentType: 'application/pdf',
          metadata: {
            contentType: 'application/pdf',
            metadata: {
              originalName: fileName
            }
          }
        });
        
        // ダウンロード用URL生成
        const [signedUrl] = await file.getSignedUrl({
          action: 'read',
          expires: '03-01-2500' // 長期間有効
        });
        
        // Firestoreにメタデータ保存
        const paperRef = admin.firestore().collection('papers').doc(paperId);
        await paperRef.set({
          id: paperId,
          uploaderId: uid,
          title: fileName.replace('.pdf', ''),
          fileUrl: signedUrl,
          fileSize: fileSize,
          processingStatus: 'pending', // 処理待ち状態
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 非同期でPDF解析処理をトリガー
        await analyzePDFBackground(paperId);
        
        return {
          success: true,
          paperId,
          fileUrl: signedUrl
        };
      } catch (error) {
        console.error('論文アップロードエラー:', error);
        throw new functions.https.HttpsError('internal', 'PDFのアップロードに失敗しました');
      }
    });
  ```

- **analyzePaper**: Vertex AIによる論文解析
  ```typescript
  // Vertex AI Gemini 2.0 Flash を使用した論文解析処理
  export const analyzePaperTask = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '4GB'
    })
    .tasks.taskQueue.onDispatch(async (data: { paperId: string }) => {
      const { paperId } = data;
      
      try {
        // 処理中ステータスに更新
        await admin.firestore().collection('papers').doc(paperId).update({
          processingStatus: 'processing',
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 論文データ取得
        const paperDoc = await admin.firestore().collection('papers').doc(paperId).get();
        const paperData = paperDoc.data();
        
        if (!paperData) {
          throw new Error('論文データが見つかりません');
        }
        
        // PDFファイルの取得
        const storage = admin.storage();
        const bucket = storage.bucket();
        const filePath = paperData.fileUrl;
        
        // ローカルに一時保存
        const tempLocalPath = `/tmp/${paperId}.pdf`;
        const pdfBuffer = await downloadFile(filePath);
        fs.writeFileSync(tempLocalPath, pdfBuffer);
        
        // PDFからテキスト抽出
        const extractedText = await extractTextFromPDF(tempLocalPath);
        
        // PDFから図表抽出
        const figures = await extractFiguresFromPDF(tempLocalPath, paperId);
        
        // Vertex AI Gemini 2.0 Flashによる解析
        const genAI = new VertexAI({project: 'your-project-id', location: 'us-central1'});
        const geminiModel = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
        
        // 論文要約と重要ポイント抽出
        const summaryPrompt = `
          以下は学術論文のテキストです。論文の重要なポイントを抽出し、以下の形式で回答してください:
          1. 要約（200語以内）
          2. 重要ポイント（箇条書きで5つ）
          3. 研究の意義（100語以内）
          4. 関連分野・トピック（5つ）
          
          論文テキスト:
          ${extractedText.substring(0, 15000)} // トークン制限を考慮
        `;
        
        const summaryResult = await geminiModel.generateContent(summaryPrompt);
        const summaryText = summaryResult.response.text();
        
        // 結果をパースして構造化
        const analysis = parseAIAnalysisResult(summaryText);
        
        // 解析結果をFirestoreに保存
        await admin.firestore().collection('papers').doc(paperId).update({
          metadata: {
            extractedText: extractedText,
            figures: figures,
          },
          aiAnalysis: analysis,
          processingStatus: 'completed',
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // 一時ファイル削除
        fs.unlinkSync(tempLocalPath);
        
        return { success: true };
      } catch (error) {
        console.error('論文解析エラー:', error);
        
        // エラー情報を保存
        await admin.firestore().collection('papers').doc(paperId).update({
          processingStatus: 'failed',
          errorLogs: admin.firestore.FieldValue.arrayUnion({
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            message: error.message || '解析処理に失敗しました',
            code: error.code || 'unknown'
          }),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        throw error;
      }
    });
    
  // 非同期タスクキューの起動関数
  async function analyzePDFBackground(paperId: string) {
    const queue = firebase.tasks().getQueue('paper-analysis-queue');
    await queue.enqueue({ paperId });
  }
  ```

- **extractFigures**: 論文から図表抽出
- **listUserPapers**: ユーザーのアップロード論文一覧取得

#### 新聞関連
- **createNewspaper**: 新聞生成開始
  ```typescript
  // 実装概要
  export const createNewspaper = functions.https.onCall(async (data, context) => {
    // 認証確認
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
    }
    
    const uid = context.auth.uid;
    const { paperIds, templateId } = data;
    
    try {
      // ユーザー情報取得
      const userDoc = await admin.firestore().collection('users').doc(uid).get();
      const userData = userDoc.data();
      
      if (!userData) {
        throw new functions.https.HttpsError('not-found', 'ユーザー情報が見つかりません');
      }
      
      // 無料会員の制限チェック
      if (userData.membershipTier === 'free') {
        // 月間生成回数チェック
        if (userData.generatedCount >= 3) {
          throw new functions.https.HttpsError(
            'resource-exhausted', 
            '無料会員の月間生成回数上限（3回）に達しました'
          );
        }
        
        // テンプレート使用可能チェック
        const templateDoc = await admin.firestore().collection('templates').doc(templateId).get();
        const templateData = templateDoc.data();
        
        if (templateData?.isPremium) {
          throw new functions.https.HttpsError(
            'permission-denied', 
            'このテンプレートは有料会員専用です'
          );
        }
      }
      
      // 論文データ取得
      const paperPromises = paperIds.map(id => 
        admin.firestore().collection('papers').doc(id).get()
      );
      const paperDocs = await Promise.all(paperPromises);
      const papers = paperDocs.map(doc => doc.data());
      
      // 論文が見つからない場合のエラー
      if (papers.some(p => !p)) {
        throw new functions.https.HttpsError('not-found', '指定された論文が見つかりません');
      }
      
      // 新規新聞ID生成
      const newspaperId = admin.firestore().collection('newspapers').doc().id;
      
      // 新聞生成タスクをキューに追加
      await generateNewspaperBackground(newspaperId, uid, paperIds, templateId);
      
      // 初期新聞エントリ作成
      await admin.firestore().collection('newspapers').doc(newspaperId).set({
        id: newspaperId,
        creatorId: uid,
        title: `新聞 - ${new Date().toLocaleDateString('ja-JP')}`,
        templateId,
        isPublic: false,
        shareSettings: {
          type: 'private',
          groupIds: [],
          viewCount: 0
        },
        content: {
          // 初期コンテンツは空
        },
        customSettings: {
          fontFamily: 'default',
          colorScheme: 'default'
        },
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      // 無料ユーザーの場合、生成回数を更新
      if (userData.membershipTier === 'free') {
        await admin.firestore().collection('users').doc(uid).update({
          generatedCount: admin.firestore.FieldValue.increment(1),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }
      
      return {
        success: true,
        newspaperId
      };
    } catch (error) {
      console.error('新聞生成エラー:', error);
      throw new functions.https.HttpsError('internal', '新聞生成の開始に失敗しました');
    }
  });
  ```

- **generateNewspaperContent**: 論文から新聞コンテンツ生成
  ```typescript
  // 新聞コンテンツ生成タスク
  export const generateNewspaperContentTask = functions
    .runWith({
      timeoutSeconds: 540, // 9分タイムアウト設定
      memory: '4GB'
    })
    .tasks.taskQueue.onDispatch(async (data: { 
      newspaperId: string, 
      uid: string, 
      paperIds: string[], 
      templateId: string 
    }) => {
      const { newspaperId, uid, paperIds, templateId } = data;
      
      try {
        // 対象論文データ取得
        const paperPromises = paperIds.map(id => 
          admin.firestore().collection('papers').doc(id).get()
        );
        const paperDocs = await Promise.all(paperPromises);
        const papers = paperDocs.map(doc => doc.data()).filter(Boolean);
        
        if (papers.length === 0) {
          throw new Error('有効な論文データが見つかりません');
        }
        
        // テンプレート情報取得
        const templateDoc = await admin.firestore().collection('templates').doc(templateId).get();
        const templateData = templateDoc.data();
        
        if (!templateData) {
          throw new Error('テンプレートが見つかりません');
        }
        
        // Vertex AI Gemini 2.0 Flashによる新聞コンテンツ生成
        const genAI = new VertexAI({project: 'your-project-id', location: 'us-central1'});
        const geminiModel = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
        
        // 論文間の関連性分析
        const paperSummaries = papers.map(p => {
          return `論文タイトル: ${p.title}\n要約: ${p.aiAnalysis?.summary || ''}\n重要ポイント: ${p.aiAnalysis?.keypoints?.join(', ') || ''}`;
        }).join('\n\n');
        
        const relationshipPrompt = `
          以下は複数の学術論文の要約です。これらの論文間の関連性を分析し、新聞記事として構成するための重要度順位付けと関連性マップを作成してください。
          
          ${paperSummaries}
          
          以下の形式で出力してください:
          1. メイン記事として扱うべき論文（最も重要または中心的な論文）
          2. サブ記事として扱うべき論文順位
          3. 論文間の関連性マップ（どの論文がどのように関連しているか）
          4. 全体を通した大きなテーマまたは研究領域
        `;
        
        const relationshipResult = await geminiModel.generateContent(relationshipPrompt);
        const relationshipAnalysis = relationshipResult.response.text();
        
        // 関連性分析に基づき、最も重要な論文を特定
        const mainPaperIndex = determineMainPaper(relationshipAnalysis, papers);
        const mainPaper = papers[mainPaperIndex];
        const subPapers = papers.filter((_, index) => index !== mainPaperIndex);
        
        // メイン記事生成
        const mainArticlePrompt = `
          あなたは優れた科学ジャーナリストです。以下の学術論文を一般読者向けの新聞記事に変換してください。
          
          論文タイトル: ${mainPaper.title}
          著者: ${mainPaper.authors?.join(', ') || '不明'}
          要約: ${mainPaper.aiAnalysis?.summary || ''}
          重要ポイント: ${mainPaper.aiAnalysis?.keypoints?.join('\n') || ''}
          
          以下の形式で新聞記事を作成してください:
          1. 見出し（20文字以内、インパクトのある表現）
          2. 小見出し（30文字以内）
          3. 本文（500字程度、一般読者にもわかりやすく研究の重要性を伝える内容）
          
          新聞記事のスタイル:
          - 最初の段落は研究の重要性を強調
          - 専門用語は極力避け、必要な場合は簡潔に説明を加える
          - 研究の社会的意義や将来の応用についても言及
          - 縦書きの新聞記事として読みやすい段落構成
        `;
        
        const mainArticleResult = await geminiModel.generateContent(mainArticlePrompt);
        const mainArticleContent = mainArticleResult.response.text();
        
        // メイン記事結果パース
        const mainArticle = parseMainArticle(mainArticleContent);
        
        // サブ記事生成
        const subArticlesPromises = subPapers.map(async (paper) => {
          const subArticlePrompt = `
            あなたは優れた科学ジャーナリストです。以下の学術論文を簡潔な新聞記事に変換してください。
            
            論文タイトル: ${paper.title}
            著者: ${paper.authors?.join(', ') || '不明'}
            要約: ${paper.aiAnalysis?.summary || ''}
            
            以下の形式で短い記事を作成してください:
            1. 見出し（15文字以内）
            2. 本文（200字程度）
            
            簡潔で一般読者にもわかりやすい内容にしてください。
          `;
          
          const subArticleResult = await geminiModel.generateContent(subArticlePrompt);
          const subArticleContent = subArticleResult.response.text();
          
          return {
            headline: extractHeadline(subArticleContent),
            content: extractContent(subArticleContent),
            paperId: paper.id,
            imageUrl: paper.metadata?.figures?.[0]?.imageUrl || ''
          };
        });
        
        const subArticles = await Promise.all(subArticlesPromises);
        
        // サイドバーコンテンツ生成
        const sidebarPrompt = `
          以下の学術論文群から抽出された情報を基に、新聞のサイドバーに掲載する内容を作成してください。
          
          ${paperSummaries}
          
          サイドバーには以下を含めてください:
          1. 関連キーワード（5-7つ）
          2. 研究分野の簡単な解説（100字程度）
          3. 今後の研究展望（100字程度）
          
          簡潔で読者の興味を引く内容にしてください。
        `;
        
        const sidebarResult = await geminiModel.generateContent(sidebarPrompt);
        const sidebarContent = sidebarResult.response.text();
        
        // 日付とヘッダー情報の生成
        const today = new Date();
        const dateStr = today.toLocaleDateString('ja-JP', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'long'
        });
        
        // 領域名から新聞名を生成
        const newspaperNamePrompt = `
          以下の学術研究分野に関連する架空の専門新聞名を考えてください。
          研究分野: ${mainPaper.aiAnalysis?.academicField || '学術研究'}
          
          例えば「○○タイムズ」「△△新聞」のような形式で、権威と専門性を感じさせる名前を1つだけ提案してください。
        `;
        
        const newspaperNameResult = await geminiModel.generateContent(newspaperNamePrompt);
        const newspaperName = newspaperNameResult.response.text().trim();
        
        // 新聞コンテンツをFirestoreに保存
        await admin.firestore().collection('newspapers').doc(newspaperId).update({
          content: {
            header: {
              newspaperName: newspaperName,
              date: dateStr,
              issueNumber: `第${Math.floor(Math.random() * 1000) + 1}号`
            },
            mainArticle: {
              headline: mainArticle.headline,
              subheadline: mainArticle.subheadline,
              content: mainArticle.content,
              imageUrl: mainPaper.metadata?.figures?.[0]?.imageUrl || '',
              paperIds: [mainPaper.id]
            },
            subArticles: subArticles,
            sidebarContent: sidebarContent,
            columnContent: generateColumnContent(papers),
            footer: `© ${today.getFullYear()} Research News Network. 本紙は学術論文を基に生成されたものです。原論文の権利は各著者に帰属します。`
          },
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        // プレビュー画像生成 (HTMLからPNG)
        await generatePreviewImage(newspaperId, templateData.layout);
        
        return {
          success: true,
          message: '新聞コンテンツが正常に生成されました'
        };
      } catch (error) {
        console.error('新聞コンテンツ生成エラー:', error);
        
        // エラー情報を更新
        await admin.firestore().collection('newspapers').doc(newspaperId).update({
          error: {
            message: error.message || 'コンテンツ生成に失敗しました',
            timestamp: admin.firestore.FieldValue.serverTimestamp()
          },
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        throw error;
      }
    });
    
  // 非同期タスクキューの起動関数
  async function generateNewspaperBackground(
    newspaperId: string, 
    uid: string, 
    paperIds: string[], 
    templateId: string
  ) {
    const queue = firebase.tasks().getQueue('newspaper-generation-queue');
    await queue.enqueue({ newspaperId, uid, paperIds, templateId });
  }
  ```

- **saveNewspaper**: 生成した新聞の保存
- **updateNewspaper**: 新聞内容の更新
- **listUserNewspapers**: ユーザーの新聞一覧取得
- **shareNewspaper**: 新聞の共有設定更新
- **exportToPdf**: 新聞をPDFに変換

#### グループ関連
- **createGroup**: 研究グループ作成
- **updateGroup**: グループ情報更新
- **addGroupMember**: グループにメンバー追加
- **removeGroupMember**: グループからメンバー削除
- **listUserGroups**: ユーザーの所属グループ一覧

#### 決済関連
- **createCheckoutSession**: Stripe決済セッション作成
- **handleSubscriptionUpdate**: サブスクリプション状態更新処理
- **cancelSubscription**: サブスクリプション解約処理

### 4.2 Vertex AI実装詳細

#### 実装アーキテクチャ
Vertex AIの実装は、Cloud Functions上で以下のように構成されています：

```
functions/
└── src/
    └── ai/
        ├── services/          # AIサービスの実装
        │   ├── BaseAIService.ts
        │   ├── PaperAnalysisService.ts
        │   └── NewspaperGenerationService.ts
        ├── prompts/          # プロンプトテンプレート
        │   ├── paper-analysis.txt
        │   └── newspaper-generation.txt
        └── utils/            # ユーティリティ
            ├── error-handling.ts
            └── monitoring.ts
```

Cloud Functionsを使用する主な理由：
1. スケーラビリティ：需要に応じて自動でスケーリング
2. サーバーレス：インフラ管理が不要
3. 非同期処理：長時間実行が必要なAI処理に適している
4. コスト効率：使用した分のみの課金

処理フロー：
1. クライアントからのリクエスト受信
2. Cloud Functions上でVertex AI APIを呼び出し
3. 結果をFirestoreに保存
4. クライアントに処理完了を通知

#### AIサービスクラス設計
```typescript
// src/ai/services/BaseAIService.ts
abstract class BaseAIService {
  protected genAI: VertexAI;
  protected model: GenerativeModel;
  
  constructor(projectId: string, location: string) {
    this.genAI = new VertexAI({project: projectId, location});
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  }
  
  protected async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    initialDelay: number = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (!this.isRetryableError(error)) throw error;
        await this.delay(initialDelay * Math.pow(2, i));
      }
    }
    
    throw lastError;
  }
  
  private isRetryableError(error: any): boolean {
    const retryableErrors = [
      'RESOURCE_EXHAUSTED',
      'UNAVAILABLE',
      'DEADLINE_EXCEEDED'
    ];
    return retryableErrors.includes(error.code);
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// src/ai/services/PaperAnalysisService.ts
class PaperAnalysisService extends BaseAIService {
  constructor(projectId: string, location: string) {
    super(projectId, location);
  }
  
  async analyzePaper(paperContent: string): Promise<PaperAnalysis> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('paper-analysis');
      const formattedPrompt = this.formatPrompt(prompt, { content: paperContent });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseAnalysisResult(result.response.text());
    });
  }
  
  async generateNewsSummary(analysis: PaperAnalysis): Promise<NewsSummary> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('news-summary');
      const formattedPrompt = this.formatPrompt(prompt, { analysis });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseNewsSummary(result.response.text());
    });
  }
  
  private async loadPromptTemplate(templateName: string): Promise<string> {
    // プロンプトテンプレートをファイルから読み込む
    const templatePath = path.join(__dirname, '../prompts', `${templateName}.txt`);
    return fs.promises.readFile(templatePath, 'utf-8');
  }
}

// src/ai/services/NewspaperGenerationService.ts
class NewspaperGenerationService extends BaseAIService {
  constructor(projectId: string, location: string) {
    super(projectId, location);
  }
  
  async generateNewspaper(papers: PaperAnalysis[]): Promise<NewspaperContent> {
    return this.withRetry(async () => {
      // 複数の論文を新聞形式にまとめる
      const prompt = await this.loadPromptTemplate('newspaper-generation');
      const formattedPrompt = this.formatPrompt(prompt, { papers });
      
      const result = await this.model.generateContent(formattedPrompt);
      return this.parseNewspaperContent(result.response.text());
    });
  }
  
  async generateHeadlines(content: string): Promise<Headlines> {
    return this.withRetry(async () => {
      const prompt = await this.loadPromptTemplate('headline-generation');
      const result = await this.model.generateContent(prompt);
      return this.parseHeadlines(result.response.text());
    });
  }
}
```

#### エラーハンドリング実装
```typescript
// src/ai/utils/error-handling.ts
export class AIServiceError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'AIServiceError';
  }
  
  static fromVertexError(error: any): AIServiceError {
    // Vertex AIのエラーを標準化されたエラーに変換
    const errorMap: { [key: string]: string } = {
      'RESOURCE_EXHAUSTED': 'RATE_LIMIT_EXCEEDED',
      'INVALID_ARGUMENT': 'INVALID_INPUT',
      'FAILED_PRECONDITION': 'SERVICE_ERROR',
      'UNAVAILABLE': 'SERVICE_UNAVAILABLE'
    };
    
    return new AIServiceError(
      errorMap[error.code] || 'UNKNOWN_ERROR',
      error.message || 'AI処理中にエラーが発生しました',
      error.details
    );
  }
}

// src/ai/utils/monitoring.ts
export class AIMonitoring {
  static async logAPICall(
    service: string,
    operation: string,
    duration: number,
    success: boolean,
    error?: Error
  ) {
    await admin.firestore().collection('ai-metrics').add({
      service,
      operation,
      duration,
      success,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : null,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
  }
}
```

#### 論文解析プロンプト設計
Vertex AI Gemini 2.0 Flashに対して適切な指示を与えるためのプロンプト設計：

1. **論文構造理解プロンプト**
```
あなたは学術論文専門のAIアシスタントです。以下のPDFから抽出されたテキストを解析し、論文の構造を特定してください。

[抽出テキスト]

以下の情報を特定して、JSON形式で出力してください:
1. 論文タイトル
2. 著者リスト
3. 所属機関
4. アブストラクト
5. キーワード
6. 章・セクション構造（階層的に）
7. 図表の参照箇所とキャプション
8. 結論
9. 参考文献
```

2. **要約生成プロンプト**
```
以下の学術論文を要約してください。専門家ではない読者にも理解できる平易な言葉で、研究の重要性と主要な発見を強調してください。

[論文テキスト]

以下の形式で回答してください:
1. 要約（200語以内）：研究の背景、目的、方法、結果、意義を含める
2. 重要ポイント（5項目）：箇条書きで研究の最も重要な側面を説明
3. 研究の意義（100語以内）：この研究が分野や社会にどのような影響を与えるか
4. 関連トピック（5つ）：この研究に関連する他の研究分野やトピック
```

3. **新聞スタイル変換プロンプト**
```
あなたは科学ジャーナリストです。以下の学術論文の内容を、一般の新聞読者向けの記事に変換してください。

論文タイトル: [タイトル]
著者: [著者リスト]
要約: [要約]

以下の新聞記事形式で執筆してください:
1. 見出し：インパクトがあり、研究の本質を捉えた20字以内の見出し
2. リード文：研究の重要性を強調した導入部（50字程度）
3. 本文：研究内容を平易に説明し、専門用語を避けた説明（400字程度）
4. 図表説明：主要な図表の内容を簡潔に説明（必要な場合のみ）
5. まとめ：研究の意義や今後の展望（50字程度）

新聞記事として、読者の興味を引き、最後まで読ませる構成にしてください。
```

#### AIモデル選定と利用方針

1. **メインAI処理**: Vertex AI Gemini 2.0 Flash
   - トークン制限: 1リクエストあたり32,000トークン
   - レスポンス速度: 低レイテンシ（平均1-3秒）
   - 使用用途:
     - 論文構造解析
     - 要約生成
     - 新聞記事スタイル変換
     - 関連性分析
   - 設定パラメータ:
     - temperature: 0.2（事実に基づく正確な出力）
     - topK: 40
     - topP: 0.8

2. **長文解析**: チャンク分割アプローチ
   - 論文をセクション単位でチャンク分割（最大8,000トークン）
   - チャンクごとに解析し、結果を統合
   - 重複情報の除去とマージアルゴリズム

3. **図表処理**: Vertex AI OCR + Vision API
   - 図表領域の検出と抽出
   - 図表内のテキスト認識
   - キャプションと図表の関連付け

4. **図表処理**:
   - 論文PDFからの図表抽出処理
   - 抽出できない図表は使用しない方針
   - 元論文の図表を改変せず正確に表示

### 4.3 エラーハンドリング戦略

エラーハンドリングは以下の階層構造で実装します：

1. **階層的エラー処理**:
   ```typescript
   // エラー型定義
   type ErrorLevel = 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';

   interface AppError extends Error {
     code: string;
     level: ErrorLevel;
     details?: any;
     timestamp: Date;
   }

   class ApplicationError implements AppError {
     name = 'ApplicationError';
     timestamp = new Date();

     constructor(
       public message: string,
       public code: string,
       public level: ErrorLevel = 'ERROR',
       public details?: any
     ) {
       this.stack = new Error().stack;
     }
   }

   // 特定のエラータイプ
   class ValidationError extends ApplicationError {
     constructor(message: string, details?: any) {
       super(message, 'VALIDATION_ERROR', 'WARN', details);
     }
   }

   class AIProcessingError extends ApplicationError {
     constructor(message: string, details?: any) {
       super(message, 'AI_PROCESSING_ERROR', 'ERROR', details);
     }
   }

   class NetworkError extends ApplicationError {
     constructor(message: string, details?: any) {
       super(message, 'NETWORK_ERROR', 'ERROR', details);
     }
   }
   ```
   - アプリケーション層エラー: ユーザー入力、権限関連
   - サービス層エラー: API連携、データ処理
   - インフラ層エラー: 接続、リソース制限

2. **リトライメカニズム**
   - 自動リトライ（Firebase Tasks Queue機能）
     - 指数バックオフ戦略
     - 最大リトライ回数: 5回
   - 永続化されたリクエスト処理

3. **エラーログとモニタリング**
   - 構造化ログ形式
   ```json
   {
     "severity": "ERROR",
     "timestamp": "2025-05-01T12:34:56Z",
     "service": "paper-analyzer",
     "paperId": "abc123",
     "error": {
       "code": "PROCESSING_ERROR",
       "message": "PDF解析中にエラーが発生しました",
       "details": { ... }
     },
     "context": { ... }
   }
   ```
   - リアルタイムアラート（Critical エラー）
   - 定期エラーレポート（日次/週次）

4. **グレースフルデグラデーション**
   - AI処理失敗時のフォールバックメカニズム
     - 部分的結果の利用
     - シンプルな代替処理の提供
   - ユーザーへの透明な通知

## 5. UI/UX詳細設計

### 5.1 Reactアーキテクチャ設計
- **コンポーネント設計アプローチ**: Atomic Design手法
  - **Atoms**: ボタン、入力フィールド、アイコン等の基本要素
  - **Molecules**: フォームグループ、カード、ナビゲーション項目等
  - **Organisms**: ヘッダー、フッター、サイドバー、フォーム等
  - **Templates**: ページレイアウトの枠組み
  - **Pages**: 実際のページコンポーネント

- **コンポーネント構造例**:
```
app/
├── (auth)/
│   ├── login/
│   │   └── page.tsx
│   └── register/
│       └── page.tsx
├── (dashboard)/
│   ├── papers/
│   │   ├── [id]/
│   │   │   └── page.tsx
│   │   └── page.tsx
│   └── newspapers/
│       ├── create/
│       │   └── page.tsx
│       ├── [id]/
│       │   └── page.tsx
│       └── page.tsx
├── api/
│   ├── papers/
│   │   └── route.ts
│   └── newspapers/
│       └── route.ts
├── layout.tsx
└── page.tsx

components/
├── ui/
│   ├── atoms/
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Typography.tsx
│   ├── molecules/
│   │   ├── FormField.tsx
│   │   ├── NewspaperCard.tsx
│   │   └── PaperItem.tsx
│   └── organisms/
│       ├── Header.tsx
│       ├── NewspaperEditor.tsx
│       └── PaperUploader.tsx
└── features/
    ├── auth/
    │   ├── LoginForm.tsx
    │   └── RegisterForm.tsx
    └── newspaper/
        ├── TemplateSelector.tsx
        └── ContentEditor.tsx
```

- **状態管理設計**:
  - **Server Components**: サーバー側のデータフェッチと状態管理
    ```typescript
    // app/newspapers/page.tsx
    async function NewspapersPage() {
      // サーバーサイドでのデータフェッチ
      const newspapers = await fetchNewspapers();
      
      return (
        <div>
          {newspapers.map(newspaper => (
            <NewspaperCard key={newspaper.id} newspaper={newspaper} />
          ))}
        </div>
      );
    }
    ```

  - **Client Components**: クライアント側の状態管理
    ```typescript
    // components/features/newspaper/Editor.tsx
    'use client';

    const NewspaperEditor = () => {
      const [content, setContent] = useState(initialContent);
      
      return (
        <div>
          <EditableContent content={content} onChange={setContent} />
          <SaveButton onSave={() => saveContent(content)} />
        </div>
      );
    };
    ```

  - **Shared State**: Server/Client間の状態共有
    ```typescript
    // lib/context/newspaper.tsx
    'use client';

    const NewspaperContext = createContext<NewspaperContextType>({});

    export function NewspaperProvider({ 
      children, 
      initialData 
    }: {
      children: React.ReactNode;
      initialData: NewspaperData;
    }) {
      const [data, setData] = useState(initialData);
      
      return (
        <NewspaperContext.Provider value={{ data, setData }}>
          {children}
        </NewspaperContext.Provider>
      );
    }
    ```

  - **Server Actions**: サーバーサイドの状態更新
    ```typescript
    // app/actions.ts
    'use server';

    export async function updateNewspaper(id: string, data: NewspaperData) {
      const result = await db.newspapers.update(id, data);
      revalidateTag('newspapers');
      return result;
    }
    ```

- **レンダリング最適化**:
  - Server ComponentsによるデフォルトSSR
  - React.memoによる不要な再レンダリング防止（Client Components）
  - useCallback/useMemoによるパフォーマンス最適化（Client Components）
  - 仮想スクロール（大量リスト表示時）
  - App Router Route Groupsによる効率的なコード分割

### 5.2 Next.js Server Components実装
- **サーバーコンポーネントの分類**:
```typescript
// app/(dashboard)/papers/page.tsx (Server Component)
export default async function PapersPage() {
  // サーバーサイドでのデータフェッチ
  const papers = await fetchPapers();
  
  return (
    <div>
      <h1>論文一覧</h1>
      <PaperList papers={papers} />
      <ClientPaperUploader /> {/* クライアントコンポーネント */}
    </div>
  );
}

// components/features/paper/PaperList.tsx (Server Component)
export default function PaperList({ papers }: { papers: Paper[] }) {
  return (
    <div className="grid gap-4">
      {papers.map(paper => (
        <PaperCard key={paper.id} paper={paper} />
      ))}
    </div>
  );
}

// components/features/paper/ClientPaperUploader.tsx (Client Component)
'use client';

export default function ClientPaperUploader() {
  const [file, setFile] = useState<File | null>(null);
  
  const handleUpload = async () => {
    // ファイルアップロード処理
  };
  
  return (
    <div>
      <input type="file" onChange={e => setFile(e.target.files?.[0])} />
      <button onClick={handleUpload}>アップロード</button>
    </div>
  );
}
```

- **データフェッチングパターン**:
```typescript
// lib/papers.ts
export async function fetchPapers() {
  // キャッシュオプションの設定
  const options: RequestInit = {
    next: {
      revalidate: 60, // 60秒間キャッシュ
      tags: ['papers']
    }
  };
  
  const res = await fetch('https://api.example.com/papers', options);
  if (!res.ok) throw new Error('Failed to fetch papers');
  
  return res.json();
}

// lib/actions.ts
'use server';

export async function updatePaper(id: string, data: PaperUpdateData) {
  // サーバーアクション
  const res = await fetch(`https://api.example.com/papers/${id}`, {
    method: 'PUT',
    body: JSON.stringify(data)
  });
  
  if (!res.ok) throw new Error('Failed to update paper');
  
  revalidateTag('papers'); // キャッシュの再検証
  return res.json();
}
```

- **エラーハンドリング**:
```typescript
// app/error.tsx
'use client';

export default function Error({
  error,
  reset
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="error-container">
      <h2>エラーが発生しました</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>再試行</button>
    </div>
  );
}

// app/(dashboard)/papers/[id]/page.tsx
export default async function PaperPage({ params }: { params: { id: string } }) {
  try {
    const paper = await fetchPaper(params.id);
    
    if (!paper) {
      notFound(); // Next.jsの404ページにリダイレクト
    }
    
    return <PaperViewer paper={paper} />;
  } catch (error) {
    throw new Error('論文の取得に失敗しました');
  }
}
```

### 5.3 Server Components最適化

#### キャッシュ戦略
```typescript
// lib/cache-config.ts
const cacheConfig = {
  // Route Segment Config
  dynamic: 'force-dynamic', // 常に動的レンダリング
  dynamicParams: true,      // 動的パラメータを許可
  revalidate: 60,          // 60秒でキャッシュ再検証
  fetchCache: 'force-cache', // 強制的にキャッシュを使用
}

// データフェッチング with キャッシング
async function fetchWithCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: { revalidate?: number; tags?: string[] } = {}
): Promise<T> {
  // Route Segmentのキャッシュ設定
  const { revalidate, tags } = options;
  
  return await fetcher();
}

// 使用例
async function PapersPage() {
  const papers = await fetchWithCache(
    'papers',
    () => db.papers.findMany(),
    { revalidate: 60, tags: ['papers'] }
  );
  
  return <PaperList papers={papers} />;
}
```

#### ストリーミングとSuspense
```typescript
// app/(dashboard)/papers/loading.tsx
export default function Loading() {
  return <LoadingSpinner />;
}

// app/(dashboard)/papers/page.tsx
import { Suspense } from 'react';

export default async function PapersPage() {
  return (
    <div>
      <h1>論文一覧</h1>
      
      <Suspense fallback={<LoadingSpinner />}>
        {/* 非同期コンポーネント */}
        <AsyncPaperList />
      </Suspense>
      
      <Suspense fallback={<LoadingSkeleton />}>
        {/* 別の非同期コンポーネント */}
        <AsyncPaperStats />
      </Suspense>
    </div>
  );
}

// コンポーネントごとのローディングUI
async function AsyncPaperList() {
  const papers = await fetchPapers();
  return <PaperList papers={papers} />;
}
```

#### 楽観的更新
```typescript
'use client';

import { experimental_useOptimistic as useOptimistic } from 'react';
import { updatePaper } from '@/lib/actions';

export function PaperEditor({ paper }) {
  // 楽観的な状態更新
  const [optimisticPaper, addOptimisticPaper] = useOptimistic(
    paper,
    (state, newTitle: string) => ({
      ...state,
      title: newTitle
    })
  );

  async function handleUpdateTitle(newTitle: string) {
    // UIを即座に更新
    addOptimisticPaper(newTitle);
    
    // バックグラウンドで実際の更新処理
    await updatePaper(paper.id, { title: newTitle });
  }

  return (
    <div>
      <h2>{optimisticPaper.title}</h2>
      <input
        type="text"
        value={optimisticPaper.title}
        onChange={(e) => handleUpdateTitle(e.target.value)}
      />
    </div>
  );
}
```

### 5.4 ページルーティングとミドルウェア
```typescript
// app/layout.tsx (Root Layout)
export default function RootLayout({
  children
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <Header />
        {children}
        <Footer />
      </body>
    </html>
  );
}

// app/(auth)/login/page.tsx
export default function LoginPage() {
  return (
    <div>
      <h1>ログイン</h1>
      <LoginForm />
    </div>
  );
}

// app/(dashboard)/newspapers/[id]/page.tsx
export default async function NewspaperPage({ params }: { params: { id: string } }) {
  const newspaper = await fetchNewspaper(params.id);
  
  return (
    <div>
      <h1>{newspaper.title}</h1>
      <NewspaperViewer data={newspaper} />
    </div>
  );
}
```

- **Middleware認証・認可**:
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import { getAuth } from '@clerk/nextjs/server';

export default async function middleware(req: NextRequest) {
  const auth = await getAuth(req);
  const isAuthPage = req.nextUrl.pathname.startsWith('/login');
  const isDashboardPage = req.nextUrl.pathname.startsWith('/dashboard');

  if (!auth.userId && isDashboardPage) {
    return NextResponse.redirect(new URL('/login', req.url));
  }

  if (auth.userId && isAuthPage) {
    return NextResponse.redirect(new URL('/dashboard', req.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|favicon.ico).*)']
};
```

- **API Routes**:
```typescript
// app/api/newspapers/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs';

export async function GET(req: Request) {
  const { userId } = auth();
  
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const searchParams = new URL(req.url).searchParams;
  const limit = parseInt(searchParams.get('limit') ?? '10');
  
  const newspapers = await db.newspapers.findMany({
    where: { userId },
    take: limit,
    orderBy: { createdAt: 'desc' }
  });
  
  return NextResponse.json({ newspapers });
}

export async function POST(req: Request) {
  const { userId } = auth();
  
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const data = await req.json();
  const result = await db.newspapers.create({
    data: {
      ...data,
      userId
    }
  });
  
  revalidateTag('newspapers');
  return NextResponse.json(result);
}
```

### 5.3 パフォーマンス最適化
  ```jsx
  // 大きなコンポーネントの遅延ロード
  const NewspaperEditor = React.lazy(() => import('./components/organisms/NewspaperEditor'));
  
  // 使用例
  function App() {
    return (
      <Suspense fallback={<LoadingSpinner />}>
        <NewspaperEditor />
      </Suspense>
    );
  }
  ```

- **画像最適化**:
  - WebP形式の使用
  - サムネイル生成（プログレッシブロード）
  - 解像度に応じた画像提供

- **キャッシュ戦略**:
  - Next.js Data Cache
  - React Server Components Cache
  - Client-side IndexedDB（オフライン対応）
  - Route Cache

### 5.5 新聞エディタのカスタムUI実装
- **縦書きテキストエディタ**:
  ```jsx
  const VerticalTextEditor = ({ value, onChange }) => {
    return (
      <div 
        className="vertical-text-container"
        style={{
          writingMode: 'vertical-rl',
          textOrientation: 'upright',
          height: '100%',
          overflowX: 'auto'
        }}
      >
        <ContentEditable
          html={value}
          onChange={onChange}
          tagName="article"
          className="vertical-text-editor"
        />
      </div>
    );
  };
  ```

- **ドラッグ&ドロップレイアウト**:
  ```jsx
  const NewspaperLayoutEditor = () => {
    // ドラッグ状態管理
    const [layout, setLayout] = useState(initialLayout);
    
    const handleDragEnd = (result) => {
      // ドラッグ処理完了後のレイアウト更新ロジック
      if (!result.destination) return;
      
      const items = Array.from(layout);
      const [reorderedItem] = items.splice(result.source.index, 1);
      items.splice(result.destination.index, 0, reorderedItem);
      
      setLayout(items);
    };
    
    return (
      <DragDropContext onDragEnd={handleDragEnd}>
        <NewspaperGrid layout={layout}>
          {layout.map((item) => (
            <Draggable key={item.id} draggableId={item.id} index={item.index}>
              {(provided) => (
                <NewspaperElement
                  ref={provided.innerRef}
                  {...provided.draggableProps}
                  {...provided.dragHandleProps}
                  item={item}
                />
              )}
            </Draggable>
          ))}
        </NewspaperGrid>
      </DragDropContext>
    );
  };
  ```

- **リアルタイムプレビュー**:
  ```jsx
  const NewspaperPreview = ({ content, template }) => {
    const [previewHtml, setPreviewHtml] = useState('');
    
    useEffect(() => {
      // コンテンツとテンプレートからHTMLを生成
      const generatePreview = async () => {
        try {
          const htmlTemplate = getTemplateHtml(template);
          const filledHtml = applyContentToTemplate(htmlTemplate, content);
          setPreviewHtml(filledHtml);
        } catch (error) {
          console.error('プレビュー生成エラー:', error);
        }
      };
      
      generatePreview();
    }, [content, template]);
    
    return (
      <div className="preview-container">
        <iframe
          title="新聞プレビュー"
          srcDoc={previewHtml}
          className="newspaper-preview"
          sandbox="allow-same-origin"
        />
      </div>
    );
  };
  ```

## 6. 新聞レイアウト詳細

### 6.1 基本レイアウト構造
実際の新聞（日本教育新聞など）と同様のレイアウト構造を採用します。特に日本の新聞の特徴である縦書きレイアウトと複数カラム構成、階層的な見出し構造を忠実に再現します。

```
┌─────────────────────────────────────────────────────────────────────────┐
│ ┌───────┐ ┌─────────────────────────────┐ ┌───────────────┐ ┌─────────┐│
│ │号数   │ │      新聞名・日付・曜日     │ │     題字     │ │ヘッダー右││
│ └───────┘ └─────────────────────────────┘ └───────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────┐ ┌─────────┐ ┌─────────────┐│
│ │                                         │ │見出し小 │ │             ││
│ │          主見出し（太ゴシック体）        │ ├─────────┤ │             ││
│ │                                         │ │         │ │             ││
│ ├─────────────────────────────────────────┤ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │   人物  │ │   右カラム  ││
│ │    │    │    │    │    │    │    │     │ │   写真  │ │    記事    ││
│ │    │    │    │    │    │    │    │     │ │         │ │  （縦書き） ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ メ │ イ │ ン │ 記 │ 事 │ 本 │ 文 │     │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ （ │ 縦 │ 書 │ き │ ・ │ 複 │ 数 │ カ   │ │         │ │             ││
│ │    │    │    │    │    │    │    │     │ │         │ │             ││
│ │ ラ │ ム │ ） │    │    │    │    │     │ ├─────────┤ │             ││
│ │    │    │    │    │    │    │    │     │ │ 小見出し │ │             ││
│ │    │    │    │    │    │    │    │     │ │（網掛け）│ │             ││
│ └─────────────────────────────────────────┘ └─────────┘ └─────────────┘│
├─────────────────────────────────────────────┬─────────────────────────┤
│ ┌─────────────────────────────────────────┐ │ ┌─────────┐ ┌─────────┐ │
│ │             │                           │ │ │         │ │         │ │
│ │  中見出し   │    下部記事（縦書き）      │ │ │ QRコード │ │  広告枠  │ │
│ │             │                           │ │ │         │ │         │ │
│ └─────────────────────────────────────────┘ │ └─────────┘ └─────────┘ │
├─────────────────────────────────────────────┼─────────────────────────┤
│ ┌─────────────────────────┐ ┌─────────────┐ │ ┌───────────────────────┐│
│ │                         │ │             │ │ │                       ││
│ │     左下部記事          │ │  図表/写真  │ │ │      右下部記事       ││
│ │    （縦書き）           │ │             │ │ │     （縦書き）        ││
│ └─────────────────────────┘ └─────────────┘ │ └───────────────────────┘│
└─────────────────────────────────────────────┴─────────────────────────┘
```

### 6.2 レイアウト実装技術
- CSS Grid + Flexboxによる複雑な新聞レイアウト実現
  ```css
  .newspaper-container {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: auto auto auto auto;
    gap: 2px;
    background-color: #fafafa;
    padding: 10px;
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
  }
  
  .newspaper-header {
    grid-column: 1 / span 6;
    grid-row: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #000;
    padding-bottom: 5px;
  }
  
  .main-headline {
    grid-column: 1 / span 4;
    grid-row: 2;
    border-bottom: 1px solid #000;
    padding: 10px 0;
  }
  
  .main-article {
    grid-column: 1 / span 4;
    grid-row: 3;
    writing-mode: vertical-rl;
    padding: 5px;
    overflow-x: auto;
    height: 500px;
  }
  
  .sidebar {
    grid-column: 5 / span 2;
    grid-row: 2 / span 2;
    writing-mode: vertical-rl;
    border-left: 1px solid #000;
    padding: 5px;
  }
  ```

- 縦書きテキスト: `writing-mode: vertical-rl`
  ```css
  .vertical-text {
    writing-mode: vertical-rl;
    text-orientation: upright;
    font-family: "游明朝", "Yu Mincho", YuMincho, serif;
    line-height: 1.8;
    letter-spacing: 0.05em;
    height: 100%;
    overflow-x: auto;
  }
  
  /* 英数字を横向きに */
  .vertical-text span.latin {
    text-orientation: mixed;
  }
  
  /* 縦中横（数字などを横書きに） */
  .tcy {
    text-combine-upright: all;
    text-orientation: upright;
  }
  ```

- 新聞特有の組版ルール適用
  ```css
  /* 行頭禁則 */
  .vertical-text {
    word-break: normal;
    overflow-wrap: break-word;
    line-break: strict;
  }
  
  /* ぶら下げ組版 */
  .hanging-punctuation {
    hanging-punctuation: force-end;
  }
  
  /* 圏点（傍点） */
  .emphasis {
    text-emphasis: filled sesame;
    text-emphasis-position: over right;
  }
  ```

### 6.3 テンプレートバリエーション実装
各テンプレートは、JSON形式で定義され、フロントエンドで動的にレンダリングされます：

```javascript
// テンプレート定義例
const classicTemplate = {
  id: "classic",
  name: "クラシック",
  description: "伝統的な活字新聞風デザイン",
  isPremium: false,
  layout: {
    version: "1.0",
    components: [
      {
        type: "header",
        id: "newspaper-header",
        position: { x: 0, y: 0 },
        size: { width: 100, height: 10 },
        styles: {
          borderBottom: "2px solid #000",
          fontFamily: "'游明朝', YuMincho, serif"
        }
      },
      {
        type: "headline",
        id: "main-headline",
        position: { x: 0, y: 10 },
        size: { width: 70, height: 10 },
        styles: {
          fontSize: "28px",
          fontWeight: "bold",
          borderBottom: "1px solid #000"
        }
      },
      {
        type: "textContent",
        id: "main-article",
        position: { x: 0, y: 20 },
        size: { width: 70, height: 50 },
        styles: {
          writingMode: "vertical-rl",
          fontFamily: "'游明朝', YuMincho, serif",
          fontSize: "16px",
          lineHeight: 1.8,
          height: "500px"
        }
      },
      // 他のコンポーネント定義...
    ]
  }
};

// テンプレートマッピング
const templateRegistry = {
  "standard": standardTemplate,
  "classic": classicTemplate,
  "modern": modernTemplate,
  // プレミアムテンプレート
  "academic": academicTemplate,
  "technical": technicalTemplate,
  // 他のテンプレート...
};

// テンプレート選択ロジック
function getTemplate(templateId, isPremiumUser) {
  const template = templateRegistry[templateId];
  
  if (!template) {
    return templateRegistry["standard"]; // デフォルト
  }
  
  if (template.isPremium && !isPremiumUser) {
    throw new Error("このテンプレートは有料会員専用です");
  }
  
  return template;
}
```

## 7. テスト計画詳細

### 7.1 単体テスト戦略
- **フロントエンドテスト**:
  ```javascript
  // Reactコンポーネントテスト例
  import { render, screen, fireEvent } from '@testing-library/react';
  import PaperUploader from './PaperUploader';
  
  describe('PaperUploader', () => {
    test('初期状態では空のドロップエリアを表示', () => {
      render(<PaperUploader onUpload={jest.fn()} />);
      
      expect(screen.getByText('PDFをドロップ')).toBeInTheDocument();
      expect(screen.queryByText('アップロード中')).not.toBeInTheDocument();
    });
    
    test('ファイル選択後、アップロードボタンが有効になる', () => {
      render(<PaperUploader onUpload={jest.fn()} />);
      
      const file = new File(['dummy content'], 'sample.pdf', { type: 'application/pdf' });
      const fileInput = screen.getByLabelText('ファイルを選択');
      
      Object.defineProperty(fileInput, 'files', {
        value: [file]
      });
      
      fireEvent.change(fileInput);
      
      expect(screen.getByText('アップロード')).toBeEnabled();
    });
  });
  ```

- **バックエンドテスト**:
  ```javascript
  // Firebase Functions テスト例
  const test = require('firebase-functions-test')();
  const admin = require('firebase-admin');
  const functions = require('../index');

  describe('uploadPaper', () => {
    beforeEach(() => {
      // Firestoreモック
      jest.spyOn(admin.firestore(), 'collection').mockImplementation(() => ({
        doc: jest.fn().mockReturnValue({
          id: 'test-paper-id',
          set: jest.fn().mockResolvedValue(true)
        })
      }));
      
      // Storageモック
      jest.spyOn(admin.storage(), 'bucket').mockImplementation(() => ({
        file: jest.fn().mockReturnValue({
          save: jest.fn().mockResolvedValue([]),
          getSignedUrl: jest.fn().mockResolvedValue(['https://test-url.com/file.pdf'])
        })
      }));
    });
    
    test('有効なPDFを処理して保存する', async () => {
      const wrapped = test.wrap(functions.uploadPaper);
      
      const data = {
        fileBase64: 'data:application/pdf;base64,dGVzdA==', // "test" in base64
        fileName: 'test.pdf',
        fileSize: 1024
      };
      
      const context = {
        auth: { uid: 'test-user' }
      };
      
      const result = await wrapped(data, context);
      
      expect(result.success).toBe(true);
      expect(result.paperId).toBe('test-paper-id');
      expect(admin.firestore().collection).toHaveBeenCalledWith('papers');
    });
  });
  ```

### 7.2 統合テスト戦略
- **エンドツーエンドテスト**:
  ```javascript
  // Cypressテスト例
  describe('新聞生成フロー', () => {
    beforeEach(() => {
      cy.login('test@example.com', 'password123');
    });
    
    it('論文をアップロードして新聞を生成できる', () => {
      // ダッシュボードに移動
      cy.visit('/dashboard');
      
      // 論文管理ページに移動
      cy.findByText('論文を管理').click();
      
      // 論文アップロード
      cy.findByText('論文をアップロード').click();
      cy.get('input[type=file]').attachFile('test-paper.pdf');
      cy.findByText('アップロード').click();
      
      // アップロード完了を確認
      cy.findByText('アップロード完了').should('be.visible');
      
      // 論文選択
      cy.get('[data-testid=paper-checkbox]').first().check();
      
      // 新聞生成開始
      cy.findByText('新聞を作成').click();
      
      // テンプレート選択
      cy.findByText('スタンダード').click();
      cy.findByText('次へ').click();
      
      // 生成中画面が表示され、その後エディタが表示されることを確認
      cy.findByText('新聞を生成中').should('be.visible');
      cy.findByText('新聞エディタ', { timeout: 60000 }).should('be.visible');
      
      // 生成された新聞の内容確認
      cy.get('.newspaper-container').should('exist');
      cy.get('.main-headline').should('not.be.empty');
    });
  });
  ```

### 7.3 ロード・パフォーマンステスト
- **負荷テスト設定**:
  ```javascript
  // k6負荷テスト例
  import http from 'k6/http';
  import { sleep, check } from 'k6';
  
  export const options = {
    stages: [
      { duration: '1m', target: 10 }, // 10ユーザーまでランプアップ
      { duration: '3m', target: 10 }, // 10ユーザーで3分間維持
      { duration: '1m', target: 50 }, // 50ユーザーまでランプアップ
      { duration: '3m', target: 50 }, // 50ユーザーで3分間維持
      { duration: '1m', target: 0 },  // ランプダウン
    ],
    thresholds: {
      http_req_duration: ['p(95)<3000'], // 95%のリクエストが3秒以内に完了すること
      http_req_failed: ['rate<0.01'],    // 失敗率1%未満
    },
  };
  
  export default function () {
    // ログイン処理
    const loginRes = http.post('https://api.example.com/login', {
      email: 'loadtest@example.com',
      password: 'password123',
    });
    
    check(loginRes, {
      'ログイン成功': (r) => r.status === 200,
    });
    
    const authToken = loginRes.json('token');
    
    // 論文一覧取得
    const papersRes = http.get('https://api.example.com/papers', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
    });
    
    check(papersRes, {
      '論文一覧取得成功': (r) => r.status === 200,
    });
    
    sleep(2);
    
    // 新聞一覧取得
    const newspapersRes = http.get('https://api.example.com/newspapers', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
    });
    
    check(newspapersRes, {
      '新聞一覧取得成功': (r) => r.status === 200,
    });
    
    sleep(3);
  }
  ```

## 8. デプロイメント・運用戦略

### 8.0 プロンプトテンプレート管理
```
functions/
└── src/
    └── ai/
        └── prompts/
            ├── paper-analysis.txt          # 論文解析用プロンプト
            ├── news-summary.txt           # ニュース要約用プロンプト
            ├── newspaper-generation.txt    # 新聞生成用プロンプト
            └── headline-generation.txt     # 見出し生成用プロンプト
```

各プロンプトファイルの内容例：

```txt
// paper-analysis.txt
システム: あなたは学術論文を解析する専門家です。以下の論文から重要な要素を抽出し、構造化された形式で出力してください。

入力: 
${paperContent}

必要な出力形式:
{
  "title": "論文タイトル",
  "authors": ["著者1", "著者2"],
  "abstract": "要約（400文字以内）",
  "keywords": ["キーワード1", "キーワード2"],
  "mainFindings": [
    "主要な発見1",
    "主要な発見2"
  ],
  "significance": "研究の意義（200文字以内）",
  "academicField": "該当する学術分野"
}

制約条件:
- 専門用語は可能な限り平易な表現に置き換える
- 重要な数値データは保持する
- 研究の新規性・独自性を明確に示す
```

```txt
// newspaper-generation.txt
システム: あなたは科学ジャーナリストです。提供された論文の解析結果を、一般読者向けの新聞記事に変換してください。

入力:
${paperAnalysis}

必要な出力形式:
{
  "headline": {
    "main": "メイン見出し（20文字以内）",
    "sub": "サブ見出し（30文字以内）"
  },
  "content": {
    "lead": "リード文（100文字以内）",
    "body": "本文（1000文字以内）",
    "conclusion": "結論（100文字以内）"
  },
  "sideInfo": {
    "keywords": ["キーワード1", "キーワード2"],
    "relatedTopics": ["関連トピック1", "関連トピック2"],
    "futureImplications": "今後の展望（100文字以内）"
  }
}

制約条件:
- 一般読者を想定し、平易な表現を使用
- 研究の社会的意義を強調
- 縦書きでの読みやすさを考慮
- 具体的な例や比喩を活用
```

この構造により：
1. プロンプトの一元管理が可能
2. バージョン管理とプロンプトの改善追跡が容易
3. 異なる言語やスタイルへの対応が柔軟
4. プロンプトの再利用と一貫性の維持が可能

### 8.1 CI/CD詳細設計
GitHub Actionsを使用したCI/CDパイプライン：

```yaml
# .github/workflows/deploy.yml
name: Deploy Application

on:
  push:
    branches: [ main, staging ]
  pull_request:
    branches: [ main, staging ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      # 環境変数設定
      - name: Set environment variables
        run: |
          if [[ $GITHUB_REF == refs/heads/main ]]; then
            echo "FIREBASE_PROJECT=production" >> $GITHUB_ENV
          else
            echo "FIREBASE_PROJECT=staging" >> $GITHUB_ENV
          fi
      
      # 依存関係インストール
      - run: npm ci
      
      # ビルド
      - run: npm run build
      
      # Firebase デプロイ
      - name: Deploy to Firebase
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          channelId: live
          projectId: '${{ env.FIREBASE_PROJECT }}'
        env:
          FIREBASE_CLI_PREVIEWS: hostingchannels
```

### 8.2 環境分離戦略
- **開発環境**:
  - Firebase Project: `research-news-dev`
  - 特徴:
    - 開発者のローカル環境に接続
    - Firestore エミュレータ使用可能
    - AI処理のモックオプション

- **ステージング環境**:
  - Firebase Project: `research-news-staging`
  - 特徴:
    - CI/CDパイプラインで自動デプロイ
    - 本番環境と同一構成
    - テストユーザーデータ

- **本番環境**:
  - Firebase Project: `research-news-prod`
  - 特徴:
    - 手動承認後デプロイ
    - バックアップ体制
    - スケーリング監視

### 8.3 モニタリング・アラート設定
- **Google Cloud Monitoringダッシュボード**:
  - リアルタイムユーザー数
  - エラー率
  - レスポンスタイム
  - リソース使用率

- **アラート設定**:
  ```yaml
  # アラートポリシー例
  policies:
    - displayName: "高エラー率検知"
      conditions:
        - displayName: "エラー率5%超過"
          condition:
            filter: "resource.type = cloud_function AND log_name = projects/research-news-prod/logs/cloudfunctions.googleapis.com%2Fcloud-functions"
            metricThreshold:
              metric: "logging.googleapis.com/log_entry_count"
              filter: "severity>=ERROR"
              aggregations:
                - alignmentPeriod: 300s
                  perSeriesAligner: ALIGN_RATE
              comparison: COMPARISON_GT
              thresholdValue: 0.05
      alertStrategy:
        notificationRateLimitPeriod: 3600s
        autoClose: 86400s
      notificationChannels:
        - "projects/research-news-prod/notificationChannels/slack-alerts"
        - "projects/research-news-prod/notificationChannels/email-dev-team"
  ```

### 8.4 バックアップ・災害復旧計画
- **バックアップスケジュール**:
  - Firestoreデータ: 日次完全バックアップ
  - Storageデータ: 週次増分バックアップ
  - 保持期間: 30日間

- **復旧時間目標 (RTO)**:
  - 重大障害時: 4時間以内
  - 軽微障害時: 2時間以内

- **復旧ポイント目標 (RPO)**:
  - データ損失許容範囲: 24時間以内

- **災害復旧テスト**:
  - 四半期ごとにリハーサル実施
  - フェイルオーバー手順の文書化と訓練

## 9. セキュリティ実装

### 9.1 認証・認可の詳細実装
- **Firebase Authentication**:
  ```javascript
  // 認証ミドルウェア実装例
  const checkAuth = async (req, res, next) => {
    try {
      const idToken = req.headers.authorization?.split('Bearer ')[1];
      
      if (!idToken) {
        return res.status(401).json({ error: '認証が必要です' });
      }
      
      const decodedToken = await admin.auth().verifyIdToken(idToken);
      req.user = decodedToken;
      
      // ユーザーデータ取得
      const userDoc = await admin.firestore().collection('users').doc(decodedToken.uid).get();
      req.userData = userDoc.data();
      
      return next();
    } catch (error) {
      console.error('認証エラー:', error);
      return res.status(401).json({ error: '認証に失敗しました' });
    }
  };
  ```

- **Firestore セキュリティルール**:
  ```
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      // ユーザーデータ
      match /users/{userId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if false; // 削除禁止
      }
      
      // 新聞データ
      match /newspapers/{newspaperId} {
        allow read: if isOwner() || isSharedWithUser() || resource.data.isPublic == true;
        allow create: if isAuthenticated() && validateNewspaper();
        allow update: if isOwner() && validateNewspaper();
        allow delete: if isOwner();
        
        function isOwner() {
          return request.auth != null && resource.data.creatorId == request.auth.uid;
        }
        
        function isSharedWithUser() {
          return request.auth != null && 
                 (resource.data.shareSettings.type == 'group' && 
                  resource.data.shareSettings.groupIds.hasAny(getUserGroups()));
        }
        
        function getUserGroups() {
          return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.groups || [];
        }
        
        function validateNewspaper() {
          return request.resource.data.creatorId == request.auth.uid;
        }
      }
      
      // 論文データ
      match /papers/{paperId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated();
        allow update: if isAuthenticated() && isPaperOwner();
        allow delete: if isPaperOwner();
        
        function isPaperOwner() {
          return request.auth.uid == resource.data.uploaderId;
        }
      }
      
      // グループデータ
      match /groups/{groupId} {
        allow read: if isGroupMember();
        allow create: if isAuthenticated();
        allow update: if isGroupAdmin();
        allow delete: if isGroupAdmin();
        
        function isGroupMember() {
          return request.auth != null && 
                exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
        }
        
        function isGroupAdmin() {
          return request.auth != null && 
                get(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)).data.role == 'admin';
        }
      }
      
      // 共通関数
      function isAuthenticated() {
        return request.auth != null;
      }
    }
  }
  ```

### 9.2 データ保護実装
- **機密データの暗号化**:
  ```javascript
  // ユーティリティ関数例
  const crypto = require('crypto');
  
  // 環境変数から暗号化キーを取得
  const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
  const IV_LENGTH = 16; // AES ブロックサイズ
  
   // エラーハンドラーの実装
   export class ErrorHandler {
     private static instance: ErrorHandler;
     private errorReporter: ErrorReporting;

     private constructor() {
       this.errorReporter = new ErrorReporting();
     }

     static getInstance(): ErrorHandler {
       if (!ErrorHandler.instance) {
         ErrorHandler.instance = new ErrorHandler();
       }
       return ErrorHandler.instance;
     }

     async handleError(error: AppError): Promise<void> {
       // エラーログ記録
       console.error(`[${error.level}] ${error.code}: ${error.message}`, error);

       // エラーメトリクス更新
       await this.updateErrorMetrics(error);

       // 重大エラーの場合、即時通知
       if (error.level === 'CRITICAL') {
         await this.notifyTeam(error);
       }

       // エラーレポートの送信
       await this.errorReporter.report(error);
     }

     private async updateErrorMetrics(error: AppError): Promise<void> {
       await admin.firestore().collection('error-metrics').add({
         code: error.code,
         level: error.level,
         timestamp: admin.firestore.FieldValue.serverTimestamp(),
         details: error.details
       });
     }

     private async notifyTeam(error: AppError): Promise<void> {
       // Slackなどへの通知処理
       const notification = {
         channel: '#alerts',
         text: `🚨 重大なエラーが発生しました:\n${error.code} - ${error.message}\n${error.details || ''}`,
         color: 'danger'
       };

       await this.sendSlackNotification(notification);
     }
   }

   // データ暗号化関数
   function encrypt(text) {
     const iv = crypto.randomBytes(IV_LENGTH);
     const cipher = crypto.createCipheriv(
       'aes-256-cbc', 
       Buffer.from(ENCRYPTION_KEY, 'hex'), 
       iv
     );
     
     let encrypted = cipher.update(text, 'utf8', 'hex');
     encrypted += cipher.final('hex');
     
     return `${iv.toString('hex')}:${encrypted}`;
   }
  
  // データ復号化関数
  function decrypt(text) {
    const textParts = text.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedText = textParts.join(':');
    const decipher = crypto.createDecipheriv(
      'aes-256-cbc',
      Buffer.from(ENCRYPTION_KEY, 'hex'),
      iv
    );
    
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  ```

- **Firebase Storage セキュリティルール**:
  ```
  rules_version = '2';
  service firebase.storage {
    match /b/{bucket}/o {
      // 論文ファイル
      match /papers/{userId}/{paperId}.pdf {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      
      // 新聞関連ファイル
      match /newspapers/{newspaperId}/{fileName} {
        allow read: if isOwnerOrShared(newspaperId);
        allow write: if isOwner(newspaperId);
      }
      
      // ユーザーカスタムロゴ
      match /logos/{userId}/{fileName} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId && isPremiumUser();
      }
      
      // ヘルパー関数
      function isOwner(newspaperId) {
        return request.auth != null && 
               firestore.get(/databases/(default)/documents/newspapers/$(newspaperId)).data.creatorId == request.auth.uid;
      }
      
      function isOwnerOrShared(newspaperId) {
        let newspaper = firestore.get(/databases/(default)/documents/newspapers/$(newspaperId)).data;
        return request.auth != null && (
          newspaper.creatorId == request.auth.uid ||
          newspaper.isPublic == true ||
          (newspaper.shareSettings.type == 'group' && hasGroupAccess(newspaper.shareSettings.groupIds))
        );
      }
      
      function hasGroupAccess(groupIds) {
        return request.auth != null && request.auth.token.groups.hasAny(groupIds);
      }
      
  function isPremiumUser() {
    return request.auth != null && 
           firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.membershipTier == 'premium';
  }

### 9.3 エラーハンドリングの実装例

#### API関数でのエラーハンドリング
```typescript
// Cloud Function実装例
export const analyzePaper = functions.https.onCall(async (data, context) => {
  const errorHandler = ErrorHandler.getInstance();
  
  try {
    // 認証チェック
    if (!context.auth) {
      throw new ValidationError('認証が必要です');
    }

    const { paperId } = data;
    if (!paperId) {
      throw new ValidationError('論文IDが指定されていません');
    }

    // 論文解析処理
    const result = await paperAnalysisService.analyzePaper(paperId);
    return { success: true, data: result };

  } catch (error) {
    // エラー処理
    if (error instanceof ValidationError) {
      // バリデーションエラーの場合
      await errorHandler.handleError(error);
      throw new functions.https.HttpsError('invalid-argument', error.message);
    } else if (error instanceof AIProcessingError) {
      // AI処理エラーの場合
      await errorHandler.handleError(error);
      throw new functions.https.HttpsError('internal', 'AI処理中にエラーが発生しました');
    } else {
      // 予期せぬエラーの場合
      const criticalError = new ApplicationError(
        '予期せぬエラーが発生しました',
        'UNEXPECTED_ERROR',
        'CRITICAL',
        { originalError: error }
      );
      await errorHandler.handleError(criticalError);
      throw new functions.https.HttpsError('internal', '予期せぬエラーが発生しました');
    }
  }
});
```

#### フロントエンドでのエラーハンドリング
```typescript
// Reactコンポーネントでのエラーハンドリング例
const PaperAnalyzer: React.FC = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const { showErrorNotification } = useNotification();

  const handleAnalyze = async (paperId: string) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await analyzePaper(paperId);
      // 成功時の処理
      
    } catch (error) {
      if (error instanceof functions.https.HttpsError) {
        switch (error.code) {
          case 'invalid-argument':
            setError(new Error('入力内容を確認してください'));
            showErrorNotification('入力エラー', error.message);
            break;
          case 'unauthenticated':
            setError(new Error('認証が必要です'));
            // ログインページへリダイレクト
            navigate('/login');
            break;
          default:
            setError(new Error('処理に失敗しました'));
            showErrorNotification('エラー', '処理に失敗しました。しばらく経ってから再度お試しください。');
            // エラーログ送信
            await logError(error);
        }
      }
    } finally {
      setIsLoading(false);
    }
  };

  // エラー表示コンポーネント
  if (error) {
    return <ErrorDisplay error={error} onRetry={() => handleAnalyze(paperId)} />;
  }

  return (
    <div>
      {isLoading ? (
        <LoadingSpinner message="論文を解析中..." />
      ) : (
        // メインコンテンツ
      )}
    </div>
  );
};
```

これにより、エラーの種類に応じた適切な処理と、ユーザーへの明確なフィードバックが可能になります。

### 9.4 セキュリティエラー対応戦略

#### 主要なエラーケースとその対処方法
1. **認証エラー**:
   - トークン期限切れ: 自動リフレッシュまたはログイン画面へ誘導
   - 無効なトークン: ログアウト処理と再認証要求
   - 権限不足: 適切な権限取得フローへ誘導

2. **API利用制限エラー**:
   - レート制限超過: 指数バックオフによる再試行
   - クォータ超過: ユーザーへの制限通知と猶予期間の提示
   - 機能制限: プレミアム会員へのアップグレード案内

3. **データ整合性エラー**:
   - 重複データ: ユニーク制約違反の検出と通知
   - 参照整合性: 関連データの存在確認と整合性維持
   - バージョン競合: 楽観的ロックによる衝突検出

4. **リソースエラー**:
   - メモリ不足: グレースフルデグラデーションとリソース解放
   - ストレージ制限: 自動クリーンアップと容量警告
   - 処理タイムアウト: 非同期処理への切り替え

#### エラー監視とアラート
```typescript
// エラー監視サービス
class ErrorMonitoringService {
  private static readonly ERROR_THRESHOLD = 10; // 10分間で10件以上でアラート
  private errorCounts: Map<string, number> = new Map();
  private readonly alertInterval = 600000; // 10分

  constructor() {
    // 定期的なカウントリセット
    setInterval(() => this.resetCounts(), this.alertInterval);
  }

  async logError(error: AppError): Promise<void> {
    const errorKey = `${error.code}_${error.level}`;
    const currentCount = (this.errorCounts.get(errorKey) || 0) + 1;
    this.errorCounts.set(errorKey, currentCount);

    // エラー閾値チェック
    if (currentCount >= ErrorMonitoringService.ERROR_THRESHOLD) {
      await this.triggerAlert(error, currentCount);
    }
  }

  private async triggerAlert(error: AppError, count: number): Promise<void> {
    const alert = {
      severity: error.level,
      message: `エラー頻度警告: ${error.code}が${count}回発生`,
      details: error.details,
      timestamp: new Date()
    };

    // アラートの送信（Slack, Email等）
    await this.sendAlert(alert);
  }
}
```

#### エラーレベルの定義と対応戦略
```typescript
// エラーレベルの定義
const enum ErrorSeverity {
  DEBUG = 'DEBUG',     // 開発時のデバッグ情報
  INFO = 'INFO',       // 正常な操作の記録
  WARN = 'WARN',       // 警告（対応が必要だが緊急ではない）
  ERROR = 'ERROR',     // エラー（即時対応が必要）
  CRITICAL = 'CRITICAL' // 重大エラー（即時対応と運用チームへの通知が必要）
}

// エラーレベルごとの対応戦略
const ErrorHandlingStrategy = {
  [ErrorSeverity.DEBUG]: {
    logLevel: 'debug',
    notification: false,
    retry: false,
    timeout: 0
  },
  [ErrorSeverity.INFO]: {
    logLevel: 'info',
    notification: false,
    retry: false,
    timeout: 0
  },
  [ErrorSeverity.WARN]: {
    logLevel: 'warn',
    notification: true,
    retry: true,
    maxRetries: 3,
    timeout: 1000
  },
  [ErrorSeverity.ERROR]: {
    logLevel: 'error',
    notification: true,
    retry: true,
    maxRetries: 5,
    timeout: 2000,
    alertChannels: ['slack-dev']
  },
  [ErrorSeverity.CRITICAL]: {
    logLevel: 'error',
    notification: true,
    retry: false,
    timeout: 0,
    alertChannels: ['slack-dev', 'slack-ops', 'email-admin'],
    escalation: true
  }
};

// エラー処理の実装例
class ErrorProcessor {
  private readonly errorHandler: ErrorHandler;
  private readonly monitoring: ErrorMonitoringService;

  constructor() {
    this.errorHandler = ErrorHandler.getInstance();
    this.monitoring = new ErrorMonitoringService();
  }

  async handleError(error: AppError): Promise<void> {
    const strategy = ErrorHandlingStrategy[error.level];
    
    // エラーログの記録
    await this.errorHandler.logError(error, strategy.logLevel);
    
    // エラー監視への通知
    await this.monitoring.logError(error);
    
    // 重大エラーの場合は即時エスカレーション
    if (strategy.escalation) {
      await this.escalateError(error);
    }
    
    // 通知が必要な場合
    if (strategy.notification) {
      await this.sendNotifications(error, strategy.alertChannels);
    }
    
    // リトライが必要な場合
    if (strategy.retry) {
      await this.retryOperation(error, strategy);
    }
  }

  private async escalateError(error: AppError): Promise<void> {
    // インシデント管理システムへの登録
    const incident = await this.createIncident(error);
    
    // オンコール担当者への通知
    await this.notifyOncallTeam(incident);
    
    // 運用ダッシュボードへの反映
    await this.updateOperationsDashboard(incident);
  }

  private async retryOperation(error: AppError, strategy: typeof ErrorHandlingStrategy[keyof typeof ErrorHandlingStrategy]): Promise<void> {
    let retryCount = 0;
    
    while (retryCount < strategy.maxRetries) {
      try {
        await new Promise(resolve => setTimeout(resolve, strategy.timeout * Math.pow(2, retryCount)));
        // 元の操作の再試行
        // ...
        break;
      } catch (retryError) {
        retryCount++;
        if (retryCount === strategy.maxRetries) {
          // 最大リトライ回数に達した場合
          await this.handleMaxRetriesExceeded(error);
        }
      }
    }
  }
}
```

#### エラーハンドリングのテスト実装
```typescript
// エラー処理のユニットテスト
describe('ErrorProcessor', () => {
  let errorProcessor: ErrorProcessor;
  let mockErrorHandler: jest.Mocked<ErrorHandler>;
  let mockMonitoring: jest.Mocked<ErrorMonitoringService>;

  beforeEach(() => {
    mockErrorHandler = {
      logError: jest.fn(),
      getInstance: jest.fn().mockReturnThis()
    } as any;

    mockMonitoring = {
      logError: jest.fn()
    } as any;

    errorProcessor = new ErrorProcessor();
    (errorProcessor as any).errorHandler = mockErrorHandler;
    (errorProcessor as any).monitoring = mockMonitoring;
  });

  test('重大エラーは即時エスカレーションされる', async () => {
    const criticalError = new ApplicationError(
      'データベース接続エラー',
      'DB_CONNECTION_ERROR',
      'CRITICAL'
    );

    const spy = jest.spyOn(errorProcessor as any, 'escalateError');
    await errorProcessor.handleError(criticalError);

    expect(spy).toHaveBeenCalledWith(criticalError);
    expect(mockMonitoring.logError).toHaveBeenCalledWith(criticalError);
  });

  test('警告レベルのエラーは再試行される', async () => {
    const warnError = new ApplicationError(
      'API呼び出し失敗',
      'API_CALL_ERROR',
      'WARN'
    );

    const spy = jest.spyOn(errorProcessor as any, 'retryOperation');
    await errorProcessor.handleError(warnError);

    expect(spy).toHaveBeenCalled();
    expect(mockMonitoring.logError).toHaveBeenCalledWith(warnError);
  });
});

// エラーハンドリング統合テスト
describe('Error Handling Integration', () => {
  it('エラー発生時に適切なフォールバック処理が実行される', async () => {
    const errorProcessor = new ErrorProcessor();
    const mockOperation = jest.fn()
      .mockRejectedValueOnce(new Error('一時的なエラー'))
      .mockResolvedValueOnce({ success: true });

    const result = await errorProcessor.executeWithFallback(
      mockOperation,
      'TEST_OPERATION'
    );

    expect(result.success).toBe(true);
    expect(mockOperation).toHaveBeenCalledTimes(2);
  });

  it('最大リトライ回数を超えた場合、エラーが通知される', async () => {
    const errorProcessor = new ErrorProcessor();
    const mockNotify = jest.spyOn(errorProcessor as any, 'notifyTeam');
    
    const mockOperation = jest.fn()
      .mockRejectedValue(new Error('persistent error'));

    await expect(errorProcessor.executeWithFallback(
      mockOperation,
      'TEST_OPERATION',
      { maxRetries: 3 }
    )).rejects.toThrow();

    expect(mockOperation).toHaveBeenCalledTimes(3);
    expect(mockNotify).toHaveBeenCalled();
  });
});
```
